{
    "sourceFile": "solar/services/auth_service.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1733410931231,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1733432010715,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,14 +1,16 @@\n # solar/services/auth_service.py\r\n-from typing import Dict, Any, Tuple\r\n+from typing import Dict, Any, Tuple, Union\r\n from datetime import datetime, timedelta\r\n from django.conf import settings\r\n-from django.contrib.auth import authenticate\r\n+from django.contrib.auth import authenticate, get_user_model\r\n import jwt\r\n \r\n from .base_service import BaseService\r\n from ..middleware.error_handler import AppError\r\n \r\n+User = get_user_model()\r\n+\r\n class AuthService(BaseService):\r\n     \"\"\"Service for handling authentication and authorization.\"\"\"\r\n \r\n     TOKEN_TYPE_ACCESS = 'access'\r\n@@ -45,17 +47,19 @@\n             return cls.format_response({\r\n                 'token': access_token,\r\n                 'refreshToken': refresh_token,\r\n                 'user': {\r\n-                    'id': user.id,\r\n+                    'id': user.pk,  # Use pk instead of id\r\n                     'username': user.username,\r\n                     'email': user.email,\r\n                     'isStaff': user.is_staff\r\n                 }\r\n             })\r\n             \r\n         except Exception as e:\r\n             cls.handle_error(e, 'LOGIN_ERROR', 'Login failed')\r\n+            # Add explicit return for type checker\r\n+            return {'success': False, 'error': str(e)}\r\n \r\n     @classmethod\r\n     def refresh_token(cls, refresh_token: str) -> Dict[str, str]:\r\n         \"\"\"\r\n@@ -81,26 +85,26 @@\n             # Check token type\r\n             if payload.get('type') != cls.TOKEN_TYPE_REFRESH:\r\n                 raise AppError('Invalid token type', 'TOKEN_ERROR')\r\n \r\n-            # Generate new tokens\r\n-            access_token, new_refresh = cls._generate_tokens(\r\n-                user_id=payload['user_id']\r\n-            )\r\n+            user = User.objects.get(pk=payload['user_id'])\r\n+            access_token, new_refresh = cls._generate_tokens(user)\r\n \r\n             return cls.format_response({\r\n                 'token': access_token,\r\n                 'refreshToken': new_refresh\r\n             })\r\n \r\n-        except jwt.InvalidTokenError as e:\r\n+        except (jwt.InvalidTokenError, User.DoesNotExist) as e:\r\n             raise AppError(\r\n                 message='Invalid refresh token',\r\n                 code='TOKEN_ERROR',\r\n                 data={'error': str(e)}\r\n             )\r\n         except Exception as e:\r\n             cls.handle_error(e, 'REFRESH_ERROR', 'Token refresh failed')\r\n+            # Add explicit return for type checker\r\n+            return {'token': '', 'refreshToken': ''}\r\n \r\n     @classmethod\r\n     def _generate_tokens(cls, user: Any) -> Tuple[str, str]:\r\n         \"\"\"\r\n@@ -113,17 +117,17 @@\n             Tuple of (access_token, refresh_token)\r\n         \"\"\"\r\n         # Access token - short lived\r\n         access_payload = {\r\n-            'user_id': user.id,\r\n+            'user_id': user.pk,  # Use pk instead of id\r\n             'type': cls.TOKEN_TYPE_ACCESS,\r\n             'exp': datetime.utcnow() + timedelta(hours=1),\r\n             'iat': datetime.utcnow()\r\n         }\r\n \r\n         # Refresh token - long lived\r\n         refresh_payload = {\r\n-            'user_id': user.id,\r\n+            'user_id': user.pk,  # Use pk instead of id\r\n             'type': cls.TOKEN_TYPE_REFRESH,\r\n             'exp': datetime.utcnow() + timedelta(days=7),\r\n             'iat': datetime.utcnow()\r\n         }\r\n"
                },
                {
                    "date": 1733432117406,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n # solar/services/auth_service.py\r\n from typing import Dict, Any, Tuple, Union\r\n-from datetime import datetime, timedelta\r\n+from datetime import datetime, timedelta, timezone\r\n from django.conf import settings\r\n from django.contrib.auth import authenticate, get_user_model\r\n import jwt\r\n \r\n@@ -97,10 +97,10 @@\n         except (jwt.InvalidTokenError, User.DoesNotExist) as e:\r\n             raise AppError(\r\n                 message='Invalid refresh token',\r\n                 code='TOKEN_ERROR',\r\n-                data={'error': str(e)}\r\n-            )\r\n+                data={'error': str(e)},\r\n+            ) from e\r\n         except Exception as e:\r\n             cls.handle_error(e, 'REFRESH_ERROR', 'Token refresh failed')\r\n             # Add explicit return for type checker\r\n             return {'token': '', 'refreshToken': ''}\r\n@@ -117,20 +117,20 @@\n             Tuple of (access_token, refresh_token)\r\n         \"\"\"\r\n         # Access token - short lived\r\n         access_payload = {\r\n-            'user_id': user.pk,  # Use pk instead of id\r\n+            'user_id': user.pk,\r\n             'type': cls.TOKEN_TYPE_ACCESS,\r\n-            'exp': datetime.utcnow() + timedelta(hours=1),\r\n-            'iat': datetime.utcnow()\r\n+            'exp': datetime.now(timezone.utc) + timedelta(hours=1),\r\n+            'iat': datetime.now(timezone.utc),\r\n         }\r\n \r\n         # Refresh token - long lived\r\n         refresh_payload = {\r\n-            'user_id': user.pk,  # Use pk instead of id\r\n+            'user_id': user.pk,\r\n             'type': cls.TOKEN_TYPE_REFRESH,\r\n-            'exp': datetime.utcnow() + timedelta(days=7),\r\n-            'iat': datetime.utcnow()\r\n+            'exp': datetime.now(timezone.utc) + timedelta(days=7),\r\n+            'iat': datetime.now(timezone.utc),\r\n         }\r\n \r\n         access_token = jwt.encode(\r\n             access_payload,\r\n@@ -165,12 +165,10 @@\n                 token,\r\n                 settings.SECRET_KEY,\r\n                 algorithms=['HS256']\r\n             )\r\n-        except jwt.ExpiredSignatureError:\r\n-            raise AppError('Token has expired', 'TOKEN_EXPIRED')\r\n+        except jwt.ExpiredSignatureError as e:\r\n+            raise AppError('Token has expired', 'TOKEN_EXPIRED') from e\r\n         except jwt.InvalidTokenError as e:\r\n             raise AppError(\r\n-                'Invalid token',\r\n-                'TOKEN_INVALID',\r\n\\ No newline at end of file\n-                {'error': str(e)}\r\n-            )\n+                'Invalid token', 'TOKEN_INVALID', {'error': str(e)}\r\n+            ) from e\n\\ No newline at end of file\n"
                }
            ],
            "date": 1733410931231,
            "name": "Commit-0",
            "content": "# solar/services/auth_service.py\r\nfrom typing import Dict, Any, Tuple\r\nfrom datetime import datetime, timedelta\r\nfrom django.conf import settings\r\nfrom django.contrib.auth import authenticate\r\nimport jwt\r\n\r\nfrom .base_service import BaseService\r\nfrom ..middleware.error_handler import AppError\r\n\r\nclass AuthService(BaseService):\r\n    \"\"\"Service for handling authentication and authorization.\"\"\"\r\n\r\n    TOKEN_TYPE_ACCESS = 'access'\r\n    TOKEN_TYPE_REFRESH = 'refresh'\r\n\r\n    @classmethod\r\n    def login(cls, username: str, password: str) -> Dict[str, Any]:\r\n        \"\"\"\r\n        Authenticate user and generate tokens.\r\n        \r\n        Args:\r\n            username: User's username\r\n            password: User's password\r\n            \r\n        Returns:\r\n            Dict containing tokens and user data\r\n            \r\n        Raises:\r\n            AppError: If authentication fails\r\n        \"\"\"\r\n        try:\r\n            cls.validate_data({'username': username, 'password': password}, \r\n                            ['username', 'password'])\r\n\r\n            user = authenticate(username=username, password=password)\r\n            if not user:\r\n                raise AppError(\r\n                    message='Invalid credentials',\r\n                    code='AUTHENTICATION_ERROR'\r\n                )\r\n\r\n            access_token, refresh_token = cls._generate_tokens(user)\r\n\r\n            return cls.format_response({\r\n                'token': access_token,\r\n                'refreshToken': refresh_token,\r\n                'user': {\r\n                    'id': user.id,\r\n                    'username': user.username,\r\n                    'email': user.email,\r\n                    'isStaff': user.is_staff\r\n                }\r\n            })\r\n            \r\n        except Exception as e:\r\n            cls.handle_error(e, 'LOGIN_ERROR', 'Login failed')\r\n\r\n    @classmethod\r\n    def refresh_token(cls, refresh_token: str) -> Dict[str, str]:\r\n        \"\"\"\r\n        Generate new access token using refresh token.\r\n        \r\n        Args:\r\n            refresh_token: Valid refresh token\r\n            \r\n        Returns:\r\n            Dict containing new tokens\r\n            \r\n        Raises:\r\n            AppError: If refresh token is invalid\r\n        \"\"\"\r\n        try:\r\n            # Verify refresh token\r\n            payload = jwt.decode(\r\n                refresh_token,\r\n                settings.SECRET_KEY,\r\n                algorithms=['HS256']\r\n            )\r\n\r\n            # Check token type\r\n            if payload.get('type') != cls.TOKEN_TYPE_REFRESH:\r\n                raise AppError('Invalid token type', 'TOKEN_ERROR')\r\n\r\n            # Generate new tokens\r\n            access_token, new_refresh = cls._generate_tokens(\r\n                user_id=payload['user_id']\r\n            )\r\n\r\n            return cls.format_response({\r\n                'token': access_token,\r\n                'refreshToken': new_refresh\r\n            })\r\n\r\n        except jwt.InvalidTokenError as e:\r\n            raise AppError(\r\n                message='Invalid refresh token',\r\n                code='TOKEN_ERROR',\r\n                data={'error': str(e)}\r\n            )\r\n        except Exception as e:\r\n            cls.handle_error(e, 'REFRESH_ERROR', 'Token refresh failed')\r\n\r\n    @classmethod\r\n    def _generate_tokens(cls, user: Any) -> Tuple[str, str]:\r\n        \"\"\"\r\n        Generate access and refresh tokens for user.\r\n        \r\n        Args:\r\n            user: User object to generate tokens for\r\n            \r\n        Returns:\r\n            Tuple of (access_token, refresh_token)\r\n        \"\"\"\r\n        # Access token - short lived\r\n        access_payload = {\r\n            'user_id': user.id,\r\n            'type': cls.TOKEN_TYPE_ACCESS,\r\n            'exp': datetime.utcnow() + timedelta(hours=1),\r\n            'iat': datetime.utcnow()\r\n        }\r\n\r\n        # Refresh token - long lived\r\n        refresh_payload = {\r\n            'user_id': user.id,\r\n            'type': cls.TOKEN_TYPE_REFRESH,\r\n            'exp': datetime.utcnow() + timedelta(days=7),\r\n            'iat': datetime.utcnow()\r\n        }\r\n\r\n        access_token = jwt.encode(\r\n            access_payload,\r\n            settings.SECRET_KEY,\r\n            algorithm='HS256'\r\n        )\r\n\r\n        refresh_token = jwt.encode(\r\n            refresh_payload,\r\n            settings.SECRET_KEY,\r\n            algorithm='HS256'\r\n        )\r\n\r\n        return access_token, refresh_token\r\n\r\n    @staticmethod\r\n    def verify_token(token: str) -> Dict[str, Any]:\r\n        \"\"\"\r\n        Verify JWT token and return payload.\r\n        \r\n        Args:\r\n            token: JWT token to verify\r\n            \r\n        Returns:\r\n            Dict containing token payload\r\n            \r\n        Raises:\r\n            AppError: If token is invalid\r\n        \"\"\"\r\n        try:\r\n            return jwt.decode(\r\n                token,\r\n                settings.SECRET_KEY,\r\n                algorithms=['HS256']\r\n            )\r\n        except jwt.ExpiredSignatureError:\r\n            raise AppError('Token has expired', 'TOKEN_EXPIRED')\r\n        except jwt.InvalidTokenError as e:\r\n            raise AppError(\r\n                'Invalid token',\r\n                'TOKEN_INVALID',\r\n                {'error': str(e)}\r\n            )"
        }
    ]
}
{
    "sourceFile": "solar/services/document_service.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1733412134976,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1733412187449,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -126,7 +126,229 @@\n         \"\"\"Generate PDF from HTML content.\"\"\"\r\n         try:\r\n             pdf = canvas.Canvas(output_path, pagesize=letter)\r\n             # Add content to PDF\r\n-            # This is a simplified version. In reality, you'd want to use\r\n-            # a more sophisticated HTML to PDF converter like WeasyPrint\r\n-            pdf.drawString(100, 750, html_content)\n\\ No newline at end of file\n+            pdf.save()\r\n+        except Exception as e:\r\n+            raise AppError(\r\n+                message='Failed to generate PDF',\r\n+                code='PDF_ERROR',\r\n+                data={'error': str(e)}\r\n+            )\r\n+\r\n+    @staticmethod\r\n+    def _ensure_directory_exists(directory: str) -> None:\r\n+        \"\"\"Create directory if it doesn't exist.\"\"\"\r\n+        os.makedirs(directory, exist_ok=True)\r\n+\r\n+    @staticmethod\r\n+    def _get_company_info() -> Dict[str, str]:\r\n+        \"\"\"Get company information for documents.\"\"\"\r\n+        return {\r\n+            'name': settings.COMPANY_NAME,\r\n+            'address': settings.COMPANY_ADDRESS,\r\n+            'phone': settings.CONTACT_PHONE,\r\n+            'email': settings.CONTACT_EMAIL,\r\n+            'website': settings.WEBSITE_URL,\r\n+            'registration': settings.COMPANY_REGISTRATION,\r\n+            'tax_id': settings.TAX_ID\r\n+        }\r\n+\r\n+    @staticmethod\r\n+    def _get_payment_info() -> Dict[str, str]:\r\n+        \"\"\"Get payment information for invoices.\"\"\"\r\n+        return {\r\n+            'bank_name': settings.BANK_NAME,\r\n+            'account_name': settings.BANK_ACCOUNT_NAME,\r\n+            'account_number': settings.BANK_ACCOUNT_NUMBER,\r\n+            'iban': settings.BANK_IBAN,\r\n+            'swift_code': settings.BANK_SWIFT\r\n+        }\r\n+\r\n+    @staticmethod\r\n+    def _get_terms_and_conditions() -> str:\r\n+        \"\"\"Get terms and conditions for agreements.\"\"\"\r\n+        terms_path = os.path.join(settings.BASE_DIR, 'templates', 'legal', 'terms.txt')\r\n+        try:\r\n+            with open(terms_path, 'r') as file:\r\n+                return file.read()\r\n+        except FileNotFoundError:\r\n+            return \"Standard terms and conditions apply.\"\r\n+\r\n+    @classmethod\r\n+    def create_document(\r\n+        cls,\r\n+        document_type: str,\r\n+        data: Dict[str, Any],\r\n+        template_override: Optional[str] = None\r\n+    ) -> Dict[str, Any]:\r\n+        \"\"\"\r\n+        Create a new document of specified type.\r\n+        \r\n+        Args:\r\n+            document_type: Type of document to create (quote/agreement/invoice/report)\r\n+            data: Document data\r\n+            template_override: Optional custom template path\r\n+            \r\n+        Returns:\r\n+            Dict containing document information including path\r\n+        \"\"\"\r\n+        try:\r\n+            if document_type not in cls.DOCUMENT_TYPES and not template_override:\r\n+                raise AppError(\r\n+                    message=f'Invalid document type: {document_type}',\r\n+                    code='INVALID_TYPE'\r\n+                )\r\n+\r\n+            generator_map = {\r\n+                'quote': cls.generate_quote_pdf,\r\n+                'agreement': cls.generate_agreement,\r\n+                'invoice': cls.generate_invoice,\r\n+                'report': cls.generate_report\r\n+            }\r\n+\r\n+            generator = generator_map.get(document_type)\r\n+            if not generator:\r\n+                raise AppError(\r\n+                    message=f'No generator for document type: {document_type}',\r\n+                    code='INVALID_TYPE'\r\n+                )\r\n+\r\n+            document_path = generator(data, template_override) if template_override else generator(data)\r\n+\r\n+            return cls.format_response({\r\n+                'path': document_path,\r\n+                'url': cls._get_document_url(document_path),\r\n+                'type': document_type,\r\n+                'created_at': datetime.now().isoformat()\r\n+            })\r\n+\r\n+        except Exception as e:\r\n+            cls.handle_error(e, 'DOCUMENT_CREATE_ERROR', 'Failed to create document')\r\n+\r\n+    @classmethod\r\n+    def get_document(cls, document_path: str) -> Dict[str, Any]:\r\n+        \"\"\"\r\n+        Get document information.\r\n+        \r\n+        Args:\r\n+            document_path: Path to the document\r\n+            \r\n+        Returns:\r\n+            Dict containing document information\r\n+        \"\"\"\r\n+        try:\r\n+            if not os.path.exists(document_path):\r\n+                raise AppError(\r\n+                    message='Document not found',\r\n+                    code='NOT_FOUND',\r\n+                    data={'path': document_path}\r\n+                )\r\n+\r\n+            file_stats = os.stat(document_path)\r\n+            return cls.format_response({\r\n+                'path': document_path,\r\n+                'url': cls._get_document_url(document_path),\r\n+                'size': file_stats.st_size,\r\n+                'created_at': datetime.fromtimestamp(file_stats.st_ctime).isoformat(),\r\n+                'modified_at': datetime.fromtimestamp(file_stats.st_mtime).isoformat()\r\n+            })\r\n+\r\n+        except Exception as e:\r\n+            cls.handle_error(e, 'DOCUMENT_FETCH_ERROR', 'Failed to get document')\r\n+\r\n+    @classmethod\r\n+    def delete_document(cls, document_path: str) -> bool:\r\n+        \"\"\"\r\n+        Delete a document.\r\n+        \r\n+        Args:\r\n+            document_path: Path to the document to delete\r\n+            \r\n+        Returns:\r\n+            True if document was deleted successfully\r\n+        \"\"\"\r\n+        try:\r\n+            if not os.path.exists(document_path):\r\n+                raise AppError(\r\n+                    message='Document not found',\r\n+                    code='NOT_FOUND',\r\n+                    data={'path': document_path}\r\n+                )\r\n+\r\n+            os.remove(document_path)\r\n+            return True\r\n+\r\n+        except Exception as e:\r\n+            cls.handle_error(e, 'DOCUMENT_DELETE_ERROR', 'Failed to delete document')\r\n+\r\n+    @staticmethod\r\n+    def _get_document_url(document_path: str) -> str:\r\n+        \"\"\"Convert document path to URL.\"\"\"\r\n+        relative_path = os.path.relpath(document_path, settings.MEDIA_ROOT)\r\n+        return f\"{settings.MEDIA_URL}{relative_path}\"\r\n+\r\n+    @classmethod\r\n+    def bulk_delete_documents(cls, document_paths: List[str]) -> Dict[str, List[str]]:\r\n+        \"\"\"\r\n+        Delete multiple documents.\r\n+        \r\n+        Args:\r\n+            document_paths: List of paths to documents to delete\r\n+            \r\n+        Returns:\r\n+            Dict containing lists of successfully and unsuccessfully deleted documents\r\n+        \"\"\"\r\n+        results = {\r\n+            'success': [],\r\n+            'failed': []\r\n+        }\r\n+\r\n+        for path in document_paths:\r\n+            try:\r\n+                if cls.delete_document(path):\r\n+                    results['success'].append(path)\r\n+                else:\r\n+                    results['failed'].append(path)\r\n+            except Exception:\r\n+                results['failed'].append(path)\r\n+\r\n+        return cls.format_response(results)\r\n+\r\n+    @classmethod\r\n+    def get_document_types(cls) -> List[str]:\r\n+        \"\"\"Get list of available document types.\"\"\"\r\n+        return list(cls.DOCUMENT_TYPES.keys())\r\n+\r\n+    @classmethod\r\n+    def validate_template(cls, template_path: str) -> bool:\r\n+        \"\"\"\r\n+        Validate a template file.\r\n+        \r\n+        Args:\r\n+            template_path: Path to template to validate\r\n+            \r\n+        Returns:\r\n+            True if template is valid\r\n+            \r\n+        Raises:\r\n+            AppError: If template is invalid\r\n+        \"\"\"\r\n+        try:\r\n+            if not os.path.exists(template_path):\r\n+                raise AppError(\r\n+                    message='Template not found',\r\n+                    code='NOT_FOUND'\r\n+                )\r\n+\r\n+            # Add template validation logic here\r\n+            # For now, just check if it's an HTML file\r\n+            if not template_path.endswith('.html'):\r\n+                raise AppError(\r\n+                    message='Invalid template format',\r\n+                    code='INVALID_FORMAT'\r\n+                )\r\n+\r\n+            return True\r\n+\r\n+        except Exception as e:\r\n+            cls.handle_error(e, 'TEMPLATE_ERROR', 'Failed to validate template')\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733430003021,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,16 +1,22 @@\n # solar/services/document_service.py\r\n-from typing import Dict, Any, Optional\r\n+from typing import Dict, Any, Optional, List\r\n import os\r\n from datetime import datetime\r\n from reportlab.lib.pagesizes import letter\r\n from reportlab.pdfgen import canvas\r\n from django.template.loader import render_to_string\r\n from django.conf import settings\r\n+import logging\r\n \r\n+# Import models\r\n+from ..models import Document  # Assuming you have a Document model\r\n+\r\n from .base_service import BaseService\r\n from ..middleware.error_handler import AppError\r\n \r\n+logger = logging.getLogger(__name__)\r\n+\r\n class DocumentService(BaseService):\r\n     \"\"\"Service for handling document generation and management.\"\"\"\r\n \r\n     DOCUMENT_TYPES = {\r\n@@ -50,8 +56,9 @@\n             return output_path\r\n \r\n         except Exception as e:\r\n             cls.handle_error(e, 'PDF_GENERATION_ERROR', 'Failed to generate quote PDF')\r\n+            raise  # Re-raise to satisfy return type\r\n \r\n     @classmethod\r\n     def generate_agreement(cls, agreement_data: Dict[str, Any]) -> str:\r\n         \"\"\"Generate installation agreement PDF.\"\"\"\r\n@@ -73,8 +80,9 @@\n             return output_path\r\n \r\n         except Exception as e:\r\n             cls.handle_error(e, 'PDF_GENERATION_ERROR', 'Failed to generate agreement PDF')\r\n+            raise\r\n \r\n     @classmethod\r\n     def generate_invoice(cls, invoice_data: Dict[str, Any]) -> str:\r\n         \"\"\"Generate customer invoice PDF.\"\"\"\r\n@@ -96,8 +104,9 @@\n             return output_path\r\n \r\n         except Exception as e:\r\n             cls.handle_error(e, 'PDF_GENERATION_ERROR', 'Failed to generate invoice PDF')\r\n+            raise\r\n \r\n     @classmethod\r\n     def generate_report(cls, report_data: Dict[str, Any], report_type: str) -> str:\r\n         \"\"\"Generate various types of reports.\"\"\"\r\n@@ -119,8 +128,9 @@\n             return output_path\r\n \r\n         except Exception as e:\r\n             cls.handle_error(e, 'PDF_GENERATION_ERROR', 'Failed to generate report PDF')\r\n+            raise\r\n \r\n     @staticmethod\r\n     def _generate_pdf(html_content: str, output_path: str) -> None:\r\n         \"\"\"Generate PDF from HTML content.\"\"\"\r\n@@ -223,8 +233,9 @@\n             })\r\n \r\n         except Exception as e:\r\n             cls.handle_error(e, 'DOCUMENT_CREATE_ERROR', 'Failed to create document')\r\n+            raise\r\n \r\n     @classmethod\r\n     def get_document(cls, document_path: str) -> Dict[str, Any]:\r\n         \"\"\"\r\n@@ -254,8 +265,9 @@\n             })\r\n \r\n         except Exception as e:\r\n             cls.handle_error(e, 'DOCUMENT_FETCH_ERROR', 'Failed to get document')\r\n+            raise\r\n \r\n     @classmethod\r\n     def delete_document(cls, document_path: str) -> bool:\r\n         \"\"\"\r\n@@ -279,8 +291,9 @@\n             return True\r\n \r\n         except Exception as e:\r\n             cls.handle_error(e, 'DOCUMENT_DELETE_ERROR', 'Failed to delete document')\r\n+            raise\r\n \r\n     @staticmethod\r\n     def _get_document_url(document_path: str) -> str:\r\n         \"\"\"Convert document path to URL.\"\"\"\r\n@@ -350,5 +363,66 @@\n \r\n             return True\r\n \r\n         except Exception as e:\r\n-            cls.handle_error(e, 'TEMPLATE_ERROR', 'Failed to validate template')\n\\ No newline at end of file\n+            cls.handle_error(e, 'TEMPLATE_ERROR', 'Failed to validate template')\r\n+            raise\r\n+\r\n+    @staticmethod\r\n+    def get_documents(document_type=None, page=1, page_size=10, search=None, sort_by='-created_at'):\r\n+        \"\"\"\r\n+        Get a paginated list of documents with optional filtering and sorting.\r\n+        \r\n+        Args:\r\n+            document_type (str, optional): Filter by document type\r\n+            page (int): Page number for pagination\r\n+            page_size (int): Number of items per page\r\n+            search (str, optional): Search term to filter documents\r\n+            sort_by (str): Field to sort by (prefix with - for descending)\r\n+            \r\n+        Returns:\r\n+            dict: Response containing paginated document list and metadata\r\n+        \"\"\"\r\n+        try:\r\n+            # Calculate offset for pagination\r\n+            offset = (page - 1) * page_size\r\n+\r\n+            # Build query filters\r\n+            filters = {}\r\n+            if document_type:\r\n+                filters['type'] = document_type\r\n+            if search:\r\n+                filters['name__icontains'] = search\r\n+\r\n+            # Get total count for pagination\r\n+            total_count = Document.objects.filter(**filters).count()\r\n+\r\n+            # Get documents with pagination and sorting\r\n+            sort_field = sort_by[1:] if sort_by.startswith('-') else sort_by\r\n+            sort_direction = '-' if sort_by.startswith('-') else ''\r\n+            \r\n+            documents = Document.objects.filter(**filters)\\\r\n+                .order_by(f'{sort_direction}{sort_field}')\\\r\n+                .skip(offset)\\\r\n+                .limit(page_size)\r\n+\r\n+            # Format response\r\n+            return {\r\n+                'success': True,\r\n+                'data': {\r\n+                    'documents': [doc.to_dict() for doc in documents],\r\n+                    'pagination': {\r\n+                        'page': page,\r\n+                        'page_size': page_size,\r\n+                        'total_count': total_count,\r\n+                        'total_pages': -(-total_count // page_size)  # Ceiling division\r\n+                    }\r\n+                }\r\n+            }\r\n+\r\n+        except Exception as e:\r\n+            logger.exception(\"Error getting documents\")\r\n+            raise AppError(\r\n+                message='Failed to retrieve documents',\r\n+                code='RETRIEVAL_ERROR',\r\n+                data={'error': str(e)}\r\n+            )\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733430076452,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -401,10 +401,9 @@\n             sort_direction = '-' if sort_by.startswith('-') else ''\r\n             \r\n             documents = Document.objects.filter(**filters)\\\r\n                 .order_by(f'{sort_direction}{sort_field}')\\\r\n-                .skip(offset)\\\r\n-                .limit(page_size)\r\n+                [offset:offset+page_size]\r\n \r\n             # Format response\r\n             return {\r\n                 'success': True,\r\n"
                },
                {
                    "date": 1733430958622,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,14 +7,15 @@\n from django.template.loader import render_to_string\r\n from django.conf import settings\r\n import logging\r\n \r\n-# Import models\r\n-from ..models import Document  # Assuming you have a Document model\r\n-\r\n+# Import base service and error handling\r\n from .base_service import BaseService\r\n from ..middleware.error_handler import AppError\r\n \r\n+# Import models\r\n+from ..models import Document\r\n+\r\n logger = logging.getLogger(__name__)\r\n \r\n class DocumentService(BaseService):\r\n     \"\"\"Service for handling document generation and management.\"\"\"\r\n"
                }
            ],
            "date": 1733412134976,
            "name": "Commit-0",
            "content": "# solar/services/document_service.py\r\nfrom typing import Dict, Any, Optional\r\nimport os\r\nfrom datetime import datetime\r\nfrom reportlab.lib.pagesizes import letter\r\nfrom reportlab.pdfgen import canvas\r\nfrom django.template.loader import render_to_string\r\nfrom django.conf import settings\r\n\r\nfrom .base_service import BaseService\r\nfrom ..middleware.error_handler import AppError\r\n\r\nclass DocumentService(BaseService):\r\n    \"\"\"Service for handling document generation and management.\"\"\"\r\n\r\n    DOCUMENT_TYPES = {\r\n        'quote': 'templates/pdf/quote_template.html',\r\n        'agreement': 'templates/pdf/agreement_template.html',\r\n        'invoice': 'templates/pdf/invoice_template.html',\r\n        'report': 'templates/pdf/report_template.html'\r\n    }\r\n\r\n    @classmethod\r\n    def generate_quote_pdf(cls, quote_data: Dict[str, Any], \r\n                          template_override: Optional[str] = None) -> str:\r\n        \"\"\"\r\n        Generate PDF quote document.\r\n        \r\n        Args:\r\n            quote_data: Dictionary containing quote information\r\n            template_override: Optional custom template path\r\n            \r\n        Returns:\r\n            Path to generated PDF file\r\n        \"\"\"\r\n        try:\r\n            template = template_override or cls.DOCUMENT_TYPES['quote']\r\n            html_content = render_to_string(template, {\r\n                'quote': quote_data,\r\n                'company_info': cls._get_company_info(),\r\n                'generated_date': datetime.now()\r\n            })\r\n\r\n            filename = f\"quote_{quote_data.get('reference_number')}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf\"\r\n            output_path = os.path.join(settings.MEDIA_ROOT, 'quotes', filename)\r\n\r\n            cls._ensure_directory_exists(os.path.dirname(output_path))\r\n            cls._generate_pdf(html_content, output_path)\r\n\r\n            return output_path\r\n\r\n        except Exception as e:\r\n            cls.handle_error(e, 'PDF_GENERATION_ERROR', 'Failed to generate quote PDF')\r\n\r\n    @classmethod\r\n    def generate_agreement(cls, agreement_data: Dict[str, Any]) -> str:\r\n        \"\"\"Generate installation agreement PDF.\"\"\"\r\n        try:\r\n            template = cls.DOCUMENT_TYPES['agreement']\r\n            html_content = render_to_string(template, {\r\n                'agreement': agreement_data,\r\n                'company_info': cls._get_company_info(),\r\n                'generated_date': datetime.now(),\r\n                'terms_and_conditions': cls._get_terms_and_conditions()\r\n            })\r\n\r\n            filename = f\"agreement_{agreement_data.get('reference_number')}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf\"\r\n            output_path = os.path.join(settings.MEDIA_ROOT, 'agreements', filename)\r\n\r\n            cls._ensure_directory_exists(os.path.dirname(output_path))\r\n            cls._generate_pdf(html_content, output_path)\r\n\r\n            return output_path\r\n\r\n        except Exception as e:\r\n            cls.handle_error(e, 'PDF_GENERATION_ERROR', 'Failed to generate agreement PDF')\r\n\r\n    @classmethod\r\n    def generate_invoice(cls, invoice_data: Dict[str, Any]) -> str:\r\n        \"\"\"Generate customer invoice PDF.\"\"\"\r\n        try:\r\n            template = cls.DOCUMENT_TYPES['invoice']\r\n            html_content = render_to_string(template, {\r\n                'invoice': invoice_data,\r\n                'company_info': cls._get_company_info(),\r\n                'payment_info': cls._get_payment_info(),\r\n                'generated_date': datetime.now()\r\n            })\r\n\r\n            filename = f\"invoice_{invoice_data.get('number')}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf\"\r\n            output_path = os.path.join(settings.MEDIA_ROOT, 'invoices', filename)\r\n\r\n            cls._ensure_directory_exists(os.path.dirname(output_path))\r\n            cls._generate_pdf(html_content, output_path)\r\n\r\n            return output_path\r\n\r\n        except Exception as e:\r\n            cls.handle_error(e, 'PDF_GENERATION_ERROR', 'Failed to generate invoice PDF')\r\n\r\n    @classmethod\r\n    def generate_report(cls, report_data: Dict[str, Any], report_type: str) -> str:\r\n        \"\"\"Generate various types of reports.\"\"\"\r\n        try:\r\n            template = cls.DOCUMENT_TYPES['report']\r\n            html_content = render_to_string(template, {\r\n                'report': report_data,\r\n                'report_type': report_type,\r\n                'company_info': cls._get_company_info(),\r\n                'generated_date': datetime.now()\r\n            })\r\n\r\n            filename = f\"report_{report_type}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf\"\r\n            output_path = os.path.join(settings.MEDIA_ROOT, 'reports', filename)\r\n\r\n            cls._ensure_directory_exists(os.path.dirname(output_path))\r\n            cls._generate_pdf(html_content, output_path)\r\n\r\n            return output_path\r\n\r\n        except Exception as e:\r\n            cls.handle_error(e, 'PDF_GENERATION_ERROR', 'Failed to generate report PDF')\r\n\r\n    @staticmethod\r\n    def _generate_pdf(html_content: str, output_path: str) -> None:\r\n        \"\"\"Generate PDF from HTML content.\"\"\"\r\n        try:\r\n            pdf = canvas.Canvas(output_path, pagesize=letter)\r\n            # Add content to PDF\r\n            # This is a simplified version. In reality, you'd want to use\r\n            # a more sophisticated HTML to PDF converter like WeasyPrint\r\n            pdf.drawString(100, 750, html_content)"
        }
    ]
}
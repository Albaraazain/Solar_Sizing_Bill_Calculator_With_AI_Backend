{
    "sourceFile": "solar/services/quote_service.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 5,
            "patches": [
                {
                    "date": 1733410563507,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1733411489194,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,160 +1,227 @@\n # solar/services/quote_service.py\r\n-from typing import Dict, Any\r\n+from typing import Dict, Any, List\r\n from decimal import Decimal\r\n+import math\r\n from django.db import transaction\r\n \r\n from .base_service import BaseService\r\n-from ..models import Panel, Inverter, PotentialCustomers, variableCosts\r\n+from .inventory_service import InventoryService\r\n+from ..models import Panel, Inverter, variableCosts, BracketCosts\r\n from ..middleware.error_handler import AppError\r\n \r\n class QuoteService(BaseService):\r\n-    \"\"\"Service for handling quote generation and management\"\"\"\r\n+    \"\"\"Service for handling solar system quotes and calculations.\"\"\"\r\n \r\n+    # Constants for calculations\r\n+    PEAK_SUN_HOURS = 4.5  # Average peak sun hours in Pakistan\r\n+    PERFORMANCE_RATIO = 0.75  # System performance ratio\r\n+    ANNUAL_DEGRADATION = 0.007  # Panel degradation rate per year\r\n+    VAT_RATE = 0.17  # VAT rate for solar equipment\r\n+    INSTALLATION_MARGIN = 0.15  # Installation profit margin\r\n+\r\n     @classmethod\r\n     def generate_quote(cls, bill_data: Dict[str, Any]) -> Dict[str, Any]:\r\n-        \"\"\"Generate a quote based on bill data\"\"\"\r\n+        \"\"\"\r\n+        Generate solar system quote based on bill data.\r\n+        \r\n+        Args:\r\n+            bill_data: Dict containing bill analysis data\r\n+            \r\n+        Returns:\r\n+            Dict containing complete quote details\r\n+            \r\n+        Raises:\r\n+            AppError: If quote generation fails\r\n+        \"\"\"\r\n         try:\r\n-            # Get default panel\r\n-            panel = Panel.objects.get(default_choice=True)\r\n-            \r\n             # Calculate system size\r\n-            yearly_units = float(bill_data.get('Total Yearly Units', 0))\r\n-            daily_avg = yearly_units / 365\r\n-            system_size_kw = daily_avg / 4\r\n-            system_size = round(system_size_kw * 1.5, 2)\r\n+            yearly_units = float(bill_data['Total Yearly Units'])\r\n+            system_size = cls._calculate_system_size(yearly_units)\r\n \r\n-            # Calculate panels needed\r\n+            # Get components\r\n+            panel = cls._get_default_panel()\r\n             panels_needed = cls._calculate_panels_needed(system_size, panel.power)\r\n-\r\n-            # Get appropriate inverter\r\n             inverter = cls._get_suitable_inverter(system_size)\r\n \r\n-            # Get variable costs\r\n-            costs = cls._get_costs(system_size)\r\n+            # Get all costs\r\n+            costs = cls._get_all_costs(system_size, panels_needed)\r\n \r\n-            # Calculate metrics\r\n+            # Calculate system metrics\r\n             calculations = cls._calculate_system_metrics(\r\n                 system_size=system_size,\r\n-                panel_cost=panel.price,\r\n-                panels_needed=panels_needed,\r\n-                inverter_cost=inverter.price,\r\n+                panel_data={'cost': panel.price, 'count': panels_needed, 'power': panel.power},\r\n+                inverter_data={'cost': inverter.price, 'brand': inverter.brand},\r\n                 costs=costs\r\n             )\r\n \r\n-            return {\r\n-                \"systemDetails\": {\r\n-                    \"systemSize\": system_size,\r\n-                    \"panelCount\": panels_needed,\r\n-                    \"panelType\": panel.brand,\r\n-                    \"inverterType\": inverter.brand,\r\n-                    \"roofArea\": panels_needed * 2,\r\n-                    \"installationTime\": \"3-5 days\",\r\n-                    \"warranty\": \"25 years\"\r\n+            return cls.format_response({\r\n+                'systemDetails': {\r\n+                    'systemSize': system_size,\r\n+                    'panelCount': panels_needed,\r\n+                    'panelType': {\r\n+                        'brand': panel.brand,\r\n+                        'power': float(panel.power)\r\n+                    },\r\n+                    'inverterType': {\r\n+                        'brand': inverter.brand,\r\n+                        'power': float(inverter.power)\r\n+                    },\r\n+                    'roofArea': panels_needed * 2,  # 2 sq meters per panel\r\n+                    'installationTime': cls._estimate_installation_time(system_size),\r\n+                    'warranty': {\r\n+                        'panels': '25 years',\r\n+                        'inverter': '5 years',\r\n+                        'installation': '2 years'\r\n+                    }\r\n                 },\r\n-                \"production\": calculations['production'],\r\n-                \"financial\": calculations['financial'],\r\n-                \"environmental\": calculations['environmental']\r\n-            }\r\n+                'production': calculations['production'],\r\n+                'financial': calculations['financial'],\r\n+                'environmental': calculations['environmental'],\r\n+                'costs': cls._format_costs_breakdown(costs)\r\n+            })\r\n \r\n         except Exception as e:\r\n             cls.handle_error(e, 'QUOTE_GENERATION_ERROR', 'Failed to generate quote')\r\n \r\n-    @staticmethod\r\n-    def _calculate_panels_needed(system_size: float, panel_power: Decimal) -> int:\r\n-        \"\"\"Calculate number of panels needed\"\"\"\r\n-        return round((system_size * 1000) / float(panel_power))\r\n+    @classmethod\r\n+    def _calculate_system_size(cls, yearly_units: float) -> float:\r\n+        \"\"\"Calculate optimal system size based on yearly consumption.\"\"\"\r\n+        daily_avg = yearly_units / 365\r\n+        base_size = daily_avg / (cls.PEAK_SUN_HOURS * cls.PERFORMANCE_RATIO)\r\n+        return math.ceil(base_size * 1.5)  # Add 50% buffer\r\n \r\n     @classmethod\r\n+    def _get_default_panel(cls) -> Panel:\r\n+        \"\"\"Get the default panel from inventory.\"\"\"\r\n+        panel = Panel.objects.filter(default_choice=True, availability=True).first()\r\n+        if not panel:\r\n+            raise AppError(\r\n+                message='No default panel configured',\r\n+                code='INVENTORY_ERROR'\r\n+            )\r\n+        return panel\r\n+\r\n+    @classmethod\r\n+    def _calculate_panels_needed(cls, system_size: float, panel_power: Decimal) -> int:\r\n+        \"\"\"Calculate number of panels needed.\"\"\"\r\n+        return math.ceil((system_size * 1000) / float(panel_power))\r\n+\r\n+    @classmethod\r\n     def _get_suitable_inverter(cls, system_size: float) -> Inverter:\r\n-        \"\"\"Get appropriate inverter for system size\"\"\"\r\n+        \"\"\"Get appropriate inverter for system size.\"\"\"\r\n         inverter = Inverter.objects.filter(\r\n-            power__gte=system_size, \r\n+            power__gte=system_size,\r\n             availability=True\r\n         ).order_by('power').first()\r\n \r\n         if not inverter:\r\n             raise AppError(\r\n-                message=\"No suitable inverter found\",\r\n-                code=\"INVENTORY_ERROR\",\r\n-                data={\"system_size\": system_size}\r\n+                message='No suitable inverter found',\r\n+                code='INVENTORY_ERROR',\r\n+                data={'system_size': system_size}\r\n             )\r\n-        \r\n         return inverter\r\n \r\n     @classmethod\r\n-    def _get_costs(cls, system_size: float) -> Dict[str, float]:\r\n-        \"\"\"Get all variable costs for the system\"\"\"\r\n+    def _get_all_costs(cls, system_size: float, panels_count: int) -> Dict[str, float]:\r\n+        \"\"\"Get all system costs.\"\"\"\r\n         try:\r\n+            # Get variable costs\r\n+            variable_costs = {\r\n+                cost.cost_name: float(cost.cost)\r\n+                for cost in variableCosts.objects.all()\r\n+            }\r\n+\r\n+            # Get bracket costs for system size\r\n+            bracket_costs = InventoryService.get_bracket_costs(system_size)\r\n+\r\n             return {\r\n-                'net_metering': float(variableCosts.objects.get(cost_name='Net Metering').cost),\r\n-                'installation': float(variableCosts.objects.get(\r\n-                    cost_name='Installation Cost per Watt'\r\n-                ).cost * system_size * 1000),\r\n-                'frame': float(variableCosts.objects.get(\r\n-                    cost_name='Frame Cost per Watt'\r\n-                ).cost * system_size * 1000),\r\n-                'labor': float(variableCosts.objects.get(\r\n-                    cost_name='Labor Cost'\r\n-                ).cost * system_size * 1000)\r\n+                'net_metering': variable_costs.get('Net Metering', 0),\r\n+                'installation': variable_costs.get('Installation Cost per Watt', 0) * system_size * 1000,\r\n+                'frame': variable_costs.get('Frame Cost per Watt', 0) * system_size * 1000,\r\n+                'labor': variable_costs.get('Labor Cost', 0) * system_size,\r\n+                'dc_cable': bracket_costs['dc_cable'],\r\n+                'ac_cable': bracket_costs['ac_cable'],\r\n+                'accessories': bracket_costs['accessories'],\r\n+                'transport': cls._calculate_transport_cost(system_size),\r\n+                'margin': cls._calculate_margin(system_size),\r\n+                'vat': cls._calculate_vat(system_size)\r\n             }\r\n-        except variableCosts.DoesNotExist as e:\r\n-            cls.handle_error(e, 'COST_CONFIG_ERROR', 'Missing cost configuration')\r\n \r\n-    @staticmethod\r\n-    def _calculate_system_metrics(system_size: float, panel_cost: Decimal, \r\n-                                panels_needed: int, inverter_cost: Decimal,\r\n-                                costs: Dict[str, float]) -> Dict[str, Any]:\r\n-        \"\"\"Calculate system metrics including production and financial\"\"\"\r\n-        daily_production = system_size * 4\r\n+        except Exception as e:\r\n+            raise AppError(\r\n+                message='Failed to retrieve costs',\r\n+                code='COST_ERROR',\r\n+                data={'error': str(e)}\r\n+            )\r\n+\r\n+    @classmethod\r\n+    def _calculate_system_metrics(\r\n+        cls, \r\n+        system_size: float,\r\n+        panel_data: Dict[str, Any],\r\n+        inverter_data: Dict[str, Any],\r\n+        costs: Dict[str, float]\r\n+    ) -> Dict[str, Any]:\r\n+        \"\"\"Calculate comprehensive system metrics.\"\"\"\r\n+        \r\n+        # Calculate production metrics\r\n+        daily_production = system_size * cls.PEAK_SUN_HOURS * cls.PERFORMANCE_RATIO\r\n         monthly_production = daily_production * 30\r\n         yearly_production = daily_production * 365\r\n \r\n-        total_panel_cost = panels_needed * float(panel_cost)\r\n-        total_cost = sum([\r\n-            total_panel_cost,\r\n-            float(inverter_cost),\r\n-            costs['net_metering'],\r\n-            costs['installation'],\r\n-            costs['frame'],\r\n-            costs['labor']\r\n-        ])\r\n+        # Calculate system costs\r\n+        total_panel_cost = float(panel_data['cost']) * panel_data['count']\r\n+        total_inverter_cost = float(inverter_data['cost'])\r\n+        \r\n+        total_cost = (\r\n+            total_panel_cost +\r\n+            total_inverter_cost +\r\n+            sum(costs.values())\r\n+        )\r\n \r\n+        # Calculate savings\r\n         annual_savings = yearly_production * 20  # Assuming PKR 20 per unit\r\n-        monthly_savings = monthly_production * 20\r\n+        monthly_savings = annual_savings / 12\r\n \r\n         return {\r\n             'production': {\r\n                 'daily': round(daily_production, 1),\r\n-                'monthly': QuoteService._generate_monthly_production(monthly_production),\r\n+                'monthly': cls._generate_monthly_production(monthly_production),\r\n                 'annual': round(yearly_production),\r\n-                'peakHours': 4.5,\r\n-                'performanceRatio': 0.75\r\n+                'peakHours': cls.PEAK_SUN_HOURS,\r\n+                'performanceRatio': cls.PERFORMANCE_RATIO,\r\n+                'yearlyDegradation': cls.ANNUAL_DEGRADATION * 100\r\n             },\r\n             'financial': {\r\n                 'systemCost': round(total_cost),\r\n                 'annualSavings': round(annual_savings),\r\n                 'monthlySavings': round(monthly_savings),\r\n                 'paybackPeriod': round(total_cost / annual_savings, 1),\r\n                 'roi': round((annual_savings / total_cost) * 100, 1),\r\n-                'savingsTimeline': QuoteService._generate_savings_timeline(\r\n-                    annual_savings, total_cost\r\n-                )\r\n+                'savingsTimeline': cls._generate_savings_timeline(\r\n+                    annual_savings,\r\n+                    total_cost\r\n+                ),\r\n+                'financingOptions': cls._generate_financing_options(total_cost)\r\n             },\r\n             'environmental': {\r\n-                'co2Offset': round(system_size * 1.2, 1),\r\n+                'co2Offset': round(system_size * 1.2, 1),  # Tons per year\r\n                 'treesEquivalent': round(system_size * 20),\r\n                 'homesEquivalent': round(yearly_production / 12000),\r\n-                'carbonFootprintReduction': round(system_size * 1000)\r\n+                'carbonFootprintReduction': round(system_size * 1000)  # kg/year\r\n             }\r\n         }\r\n \r\n-    @staticmethod\r\n-    def _generate_monthly_production(base_production: float) -> List[Dict[str, Any]]:\r\n-        \"\"\"Generate monthly production estimates with seasonal variations\"\"\"\r\n+    @classmethod\r\n+    def _generate_monthly_production(cls, base_production: float) -> List[Dict[str, Any]]:\r\n+        \"\"\"Generate monthly production estimates with seasonal variations.\"\"\"\r\n         seasonal_factors = {\r\n-            'winter': 0.7, 'spring': 0.9,\r\n-            'summer': 1.2, 'fall': 0.8\r\n+            'winter': 0.7,  # Nov-Feb\r\n+            'spring': 0.9,  # Mar-Apr\r\n+            'summer': 1.2,  # May-Aug\r\n+            'fall': 0.8     # Sep-Oct\r\n         }\r\n \r\n         months = [\r\n             ('Jan', 'winter'), ('Feb', 'winter'), ('Mar', 'spring'),\r\n@@ -163,18 +230,116 @@\n             ('Oct', 'fall'), ('Nov', 'winter'), ('Dec', 'winter')\r\n         ]\r\n \r\n         return [{\r\n-            \"month\": month,\r\n-            \"production\": round(base_production * factor),\r\n-            \"consumption\": round(base_production * 0.9)\r\n-        } for month, season in months \r\n-          for factor in [seasonal_factors[season]]]\r\n+            'month': month,\r\n+            'production': round(base_production * seasonal_factors[season]),\r\n+            'efficiency': round(seasonal_factors[season] * 100, 1)\r\n+        } for month, season in months]\r\n \r\n+    @classmethod\r\n+    def _generate_savings_timeline(\r\n+        cls,\r\n+        annual_savings: float,\r\n\\ No newline at end of file\n+        system_cost: float,\r\n+        years: int = 25\r\n+    ) -> List[Dict[str, Any]]:\r\n+        \"\"\"Generate long-term savings projection.\"\"\"\r\n+        return [{\r\n+            'year': year + 1,\r\n+            'annualSavings': round(\r\n+                annual_savings * (1 + (year * 0.05)) * \r\n+                (1 - cls.ANNUAL_DEGRADATION) ** year\r\n+            ),\r\n+            'cumulativeSavings': round(\r\n+                annual_savings * (year + 1) * \r\n+                (1 + (year * 0.025)) * \r\n+                (1 - cls.ANNUAL_DEGRADATION) ** year\r\n+            )\r\n+        } for year in range(years)]\r\n+\r\n+    @classmethod\r\n+    def _generate_financing_options(cls, total_cost: float) -> List[Dict[str, Any]]:\r\n+        \"\"\"Generate financing options for the system.\"\"\"\r\n+        return [\r\n+            {\r\n+                'name': 'Full Payment',\r\n+                'downPayment': round(total_cost),\r\n+                'monthlyPayment': 0,\r\n+                'term': 0,\r\n+                'totalCost': round(total_cost)\r\n+            },\r\n+            {\r\n+                'name': '50% Down Payment',\r\n+                'downPayment': round(total_cost * 0.5),\r\n+                'monthlyPayment': round((total_cost * 0.5) / 12),\r\n+                'term': 12,\r\n+                'totalCost': round(total_cost * 1.1)  # 10% financing cost\r\n+            },\r\n+            {\r\n+                'name': '25% Down Payment',\r\n+                'downPayment': round(total_cost * 0.25),\r\n+                'monthlyPayment': round((total_cost * 0.75) / 24),\r\n+                'term': 24,\r\n+                'totalCost': round(total_cost * 1.2)  # 20% financing cost\r\n+            }\r\n+        ]\r\n+\r\n     @staticmethod\r\n-    def _generate_savings_timeline(annual_savings: float, system_cost: float) -> List[Dict[str, Any]]:\r\n-        \"\"\"Generate 25-year savings timeline with inflation adjustment\"\"\"\r\n-        return [{\r\n-            \"year\": year + 1,\r\n-            \"annualSavings\": round(annual_savings * (1 + (year * 0.05))),\r\n-            \"cumulativeSavings\": round(annual_savings * (year + 1) * (1 + (year * 0.025)))\r\n-        } for year in range(25)]\n+    def _estimate_installation_time(system_size: float) -> str:\r\n+        \"\"\"Estimate installation time based on system size.\"\"\"\r\n+        if system_size <= 5:\r\n+            return \"2-3 days\"\r\n+        elif system_size <= 10:\r\n+            return \"3-5 days\"\r\n+        else:\r\n+            return \"5-7 days\"\r\n+\r\n+    @staticmethod\r\n+    def _calculate_transport_cost(system_size: float) -> float:\r\n+        \"\"\"Calculate transportation cost based on system size.\"\"\"\r\n+        base_cost = 10000  # Base transport cost\r\n+        return base_cost * math.ceil(system_size / 5)  # Increase per 5kW\r\n+\r\n+    @staticmethod\r\n+    def _calculate_margin(system_size: float) -> float:\r\n+        \"\"\"Calculate installation margin.\"\"\"\r\n+        return system_size * 1000 * 0.15  # 15% margin\r\n+\r\n+    @staticmethod\r\n+    def _calculate_vat(system_size: float) -> float:\r\n+        \"\"\"Calculate VAT amount.\"\"\"\r\n+        return system_size * 1000 * 0.17  # 17% VAT\r\n+\r\n+    @staticmethod\r\n+    def _format_costs_breakdown(costs: Dict[str, float]) -> Dict[str, Any]:\r\n+        \"\"\"Format costs for client presentation.\"\"\"\r\n+        total = sum(costs.values())\r\n+        \r\n+        return {\r\n+            'details': {\r\n+                category: {\r\n+                    'amount': round(amount),\r\n+                    'percentage': round((amount / total) * 100, 1)\r\n+                }\r\n+                for category, amount in costs.items()\r\n+            },\r\n+            'total': round(total),\r\n+            'summary': {\r\n+                'equipment': round(sum([\r\n+                    costs['dc_cable'], \r\n+                    costs['ac_cable'],\r\n+                    costs['accessories']\r\n+                ])),\r\n+                'installation': round(sum([\r\n+                    costs['installation'],\r\n+                    costs['labor'],\r\n+                    costs['frame']\r\n+                ])),\r\n+                'other': round(sum([\r\n+                    costs['net_metering'],\r\n+                    costs['transport'],\r\n+                    costs['margin'],\r\n+                    costs['vat']\r\n+                ]))\r\n+            }\r\n+        }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733411538769,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,9 +80,9 @@\n                 'costs': cls._format_costs_breakdown(costs)\r\n             })\r\n \r\n         except Exception as e:\r\n-            cls.handle_error(e, 'QUOTE_GENERATION_ERROR', 'Failed to generate quote')\r\n+            raise AppError(message='Failed to generate quote', code='QUOTE_GENERATION_ERROR', data={'error': str(e)})\r\n \r\n     @classmethod\r\n     def _calculate_system_size(cls, yearly_units: float) -> float:\r\n         \"\"\"Calculate optimal system size based on yearly consumption.\"\"\"\r\n"
                },
                {
                    "date": 1733414396967,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,9 +5,9 @@\n from django.db import transaction\r\n \r\n from .base_service import BaseService\r\n from .inventory_service import InventoryService\r\n-from ..models import Panel, Inverter, variableCosts, BracketCosts\r\n+from ..models import Panel, Inverter, VariableCosts, BracketCosts\r\n from ..middleware.error_handler import AppError\r\n \r\n class QuoteService(BaseService):\r\n     \"\"\"Service for handling solar system quotes and calculations.\"\"\"\r\n@@ -128,9 +128,9 @@\n         try:\r\n             # Get variable costs\r\n             variable_costs = {\r\n                 cost.cost_name: float(cost.cost)\r\n-                for cost in variableCosts.objects.all()\r\n+                for cost in VariableCosts.objects.all()\r\n             }\r\n \r\n             # Get bracket costs for system size\r\n             bracket_costs = InventoryService.get_bracket_costs(system_size)\r\n"
                },
                {
                    "date": 1733430249661,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -341,5 +341,102 @@\n                     costs['margin'],\r\n                     costs['vat']\r\n                 ]))\r\n             }\r\n-        }\n\\ No newline at end of file\n+        }\r\n+\r\n+    @classmethod\r\n+    def get_quote_by_id(cls, quote_id: int) -> Dict[str, Any]:\r\n+        \"\"\"\r\n+        Retrieve quote details by ID.\r\n+        \r\n+        Args:\r\n+            quote_id: ID of the quote to retrieve\r\n+            \r\n+        Returns:\r\n+            Dict containing quote details\r\n+            \r\n+        Raises:\r\n+            AppError: If quote not found or retrieval fails\r\n+        \"\"\"\r\n+        try:\r\n+            quote = Quote.objects.select_related('bill').get(id=quote_id)\r\n+            return cls.format_response({\r\n+                'quote': {\r\n+                    'id': quote.id,\r\n+                    'systemSize': float(quote.system_size),\r\n+                    'totalCost': float(quote.total_cost),\r\n+                    'createdAt': quote.created_at.isoformat(),\r\n+                    'bill': {\r\n+                        'referenceNumber': quote.bill.reference_number,\r\n+                        'customerName': quote.bill.customer_name,\r\n+                        'amount': float(quote.bill.amount),\r\n+                        'unitsConsumed': quote.bill.units_consumed\r\n+                    }\r\n+                }\r\n+            })\r\n+        except Quote.DoesNotExist:\r\n+            raise AppError(\r\n+                message='Quote not found',\r\n+                code='NOT_FOUND_ERROR',\r\n+                data={'quote_id': quote_id}\r\n+            )\r\n+        except Exception as e:\r\n+            raise AppError(\r\n+                message='Failed to retrieve quote',\r\n+                code='RETRIEVAL_ERROR',\r\n+                data={'error': str(e)}\r\n+            )\r\n+\r\n+    @classmethod\r\n+    def save_quote(cls, quote_data: Dict[str, Any], customer_data: Dict[str, Any]) -> Dict[str, Any]:\r\n+        \"\"\"\r\n+        Save quote with customer details.\r\n+        \r\n+        Args:\r\n+            quote_data: Dict containing quote information\r\n+            customer_data: Dict containing customer details\r\n+            \r\n+        Returns:\r\n+            Dict containing saved quote details\r\n+            \r\n+        Raises:\r\n+            AppError: If save operation fails\r\n+        \"\"\"\r\n+        try:\r\n+            with transaction.atomic():\r\n+                # Create or update bill record\r\n+                bill, _ = Bill.objects.update_or_create(\r\n+                    reference_number=customer_data.get('reference_number'),\r\n+                    defaults={\r\n+                        'customer_name': customer_data.get('name'),\r\n+                        'amount': quote_data.get('amount', 0),\r\n+                        'units_consumed': quote_data.get('units', 0),\r\n+                        'issue_date': quote_data.get('issue_date'),\r\n+                        'due_date': quote_data.get('due_date')\r\n+                    }\r\n+                )\r\n+\r\n+                # Create quote record\r\n+                quote = Quote.objects.create(\r\n+                    bill=bill,\r\n+                    system_size=quote_data.get('system_size'),\r\n+                    total_cost=quote_data.get('total_cost')\r\n+                )\r\n+\r\n+                return cls.format_response({\r\n+                    'quote': {\r\n+                        'id': quote.id,\r\n+                        'referenceNumber': bill.reference_number,\r\n+                        'customerName': bill.customer_name,\r\n+                        'systemSize': float(quote.system_size),\r\n+                        'totalCost': float(quote.total_cost),\r\n+                        'createdAt': quote.created_at.isoformat()\r\n+                    }\r\n+                })\r\n+\r\n+        except Exception as e:\r\n+            raise AppError(\r\n+                message='Failed to save quote',\r\n+                code='SAVE_ERROR',\r\n+                data={'error': str(e)}\r\n+            )\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733430306229,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,9 +5,9 @@\n from django.db import transaction\r\n \r\n from .base_service import BaseService\r\n from .inventory_service import InventoryService\r\n-from ..models import Panel, Inverter, VariableCosts, BracketCosts\r\n+from ..models import Bill, Panel, Inverter, Quote, VariableCosts, BracketCosts\r\n from ..middleware.error_handler import AppError\r\n \r\n class QuoteService(BaseService):\r\n     \"\"\"Service for handling solar system quotes and calculations.\"\"\"\r\n"
                }
            ],
            "date": 1733410563507,
            "name": "Commit-0",
            "content": "# solar/services/quote_service.py\r\nfrom typing import Dict, Any\r\nfrom decimal import Decimal\r\nfrom django.db import transaction\r\n\r\nfrom .base_service import BaseService\r\nfrom ..models import Panel, Inverter, PotentialCustomers, variableCosts\r\nfrom ..middleware.error_handler import AppError\r\n\r\nclass QuoteService(BaseService):\r\n    \"\"\"Service for handling quote generation and management\"\"\"\r\n\r\n    @classmethod\r\n    def generate_quote(cls, bill_data: Dict[str, Any]) -> Dict[str, Any]:\r\n        \"\"\"Generate a quote based on bill data\"\"\"\r\n        try:\r\n            # Get default panel\r\n            panel = Panel.objects.get(default_choice=True)\r\n            \r\n            # Calculate system size\r\n            yearly_units = float(bill_data.get('Total Yearly Units', 0))\r\n            daily_avg = yearly_units / 365\r\n            system_size_kw = daily_avg / 4\r\n            system_size = round(system_size_kw * 1.5, 2)\r\n\r\n            # Calculate panels needed\r\n            panels_needed = cls._calculate_panels_needed(system_size, panel.power)\r\n\r\n            # Get appropriate inverter\r\n            inverter = cls._get_suitable_inverter(system_size)\r\n\r\n            # Get variable costs\r\n            costs = cls._get_costs(system_size)\r\n\r\n            # Calculate metrics\r\n            calculations = cls._calculate_system_metrics(\r\n                system_size=system_size,\r\n                panel_cost=panel.price,\r\n                panels_needed=panels_needed,\r\n                inverter_cost=inverter.price,\r\n                costs=costs\r\n            )\r\n\r\n            return {\r\n                \"systemDetails\": {\r\n                    \"systemSize\": system_size,\r\n                    \"panelCount\": panels_needed,\r\n                    \"panelType\": panel.brand,\r\n                    \"inverterType\": inverter.brand,\r\n                    \"roofArea\": panels_needed * 2,\r\n                    \"installationTime\": \"3-5 days\",\r\n                    \"warranty\": \"25 years\"\r\n                },\r\n                \"production\": calculations['production'],\r\n                \"financial\": calculations['financial'],\r\n                \"environmental\": calculations['environmental']\r\n            }\r\n\r\n        except Exception as e:\r\n            cls.handle_error(e, 'QUOTE_GENERATION_ERROR', 'Failed to generate quote')\r\n\r\n    @staticmethod\r\n    def _calculate_panels_needed(system_size: float, panel_power: Decimal) -> int:\r\n        \"\"\"Calculate number of panels needed\"\"\"\r\n        return round((system_size * 1000) / float(panel_power))\r\n\r\n    @classmethod\r\n    def _get_suitable_inverter(cls, system_size: float) -> Inverter:\r\n        \"\"\"Get appropriate inverter for system size\"\"\"\r\n        inverter = Inverter.objects.filter(\r\n            power__gte=system_size, \r\n            availability=True\r\n        ).order_by('power').first()\r\n\r\n        if not inverter:\r\n            raise AppError(\r\n                message=\"No suitable inverter found\",\r\n                code=\"INVENTORY_ERROR\",\r\n                data={\"system_size\": system_size}\r\n            )\r\n        \r\n        return inverter\r\n\r\n    @classmethod\r\n    def _get_costs(cls, system_size: float) -> Dict[str, float]:\r\n        \"\"\"Get all variable costs for the system\"\"\"\r\n        try:\r\n            return {\r\n                'net_metering': float(variableCosts.objects.get(cost_name='Net Metering').cost),\r\n                'installation': float(variableCosts.objects.get(\r\n                    cost_name='Installation Cost per Watt'\r\n                ).cost * system_size * 1000),\r\n                'frame': float(variableCosts.objects.get(\r\n                    cost_name='Frame Cost per Watt'\r\n                ).cost * system_size * 1000),\r\n                'labor': float(variableCosts.objects.get(\r\n                    cost_name='Labor Cost'\r\n                ).cost * system_size * 1000)\r\n            }\r\n        except variableCosts.DoesNotExist as e:\r\n            cls.handle_error(e, 'COST_CONFIG_ERROR', 'Missing cost configuration')\r\n\r\n    @staticmethod\r\n    def _calculate_system_metrics(system_size: float, panel_cost: Decimal, \r\n                                panels_needed: int, inverter_cost: Decimal,\r\n                                costs: Dict[str, float]) -> Dict[str, Any]:\r\n        \"\"\"Calculate system metrics including production and financial\"\"\"\r\n        daily_production = system_size * 4\r\n        monthly_production = daily_production * 30\r\n        yearly_production = daily_production * 365\r\n\r\n        total_panel_cost = panels_needed * float(panel_cost)\r\n        total_cost = sum([\r\n            total_panel_cost,\r\n            float(inverter_cost),\r\n            costs['net_metering'],\r\n            costs['installation'],\r\n            costs['frame'],\r\n            costs['labor']\r\n        ])\r\n\r\n        annual_savings = yearly_production * 20  # Assuming PKR 20 per unit\r\n        monthly_savings = monthly_production * 20\r\n\r\n        return {\r\n            'production': {\r\n                'daily': round(daily_production, 1),\r\n                'monthly': QuoteService._generate_monthly_production(monthly_production),\r\n                'annual': round(yearly_production),\r\n                'peakHours': 4.5,\r\n                'performanceRatio': 0.75\r\n            },\r\n            'financial': {\r\n                'systemCost': round(total_cost),\r\n                'annualSavings': round(annual_savings),\r\n                'monthlySavings': round(monthly_savings),\r\n                'paybackPeriod': round(total_cost / annual_savings, 1),\r\n                'roi': round((annual_savings / total_cost) * 100, 1),\r\n                'savingsTimeline': QuoteService._generate_savings_timeline(\r\n                    annual_savings, total_cost\r\n                )\r\n            },\r\n            'environmental': {\r\n                'co2Offset': round(system_size * 1.2, 1),\r\n                'treesEquivalent': round(system_size * 20),\r\n                'homesEquivalent': round(yearly_production / 12000),\r\n                'carbonFootprintReduction': round(system_size * 1000)\r\n            }\r\n        }\r\n\r\n    @staticmethod\r\n    def _generate_monthly_production(base_production: float) -> List[Dict[str, Any]]:\r\n        \"\"\"Generate monthly production estimates with seasonal variations\"\"\"\r\n        seasonal_factors = {\r\n            'winter': 0.7, 'spring': 0.9,\r\n            'summer': 1.2, 'fall': 0.8\r\n        }\r\n\r\n        months = [\r\n            ('Jan', 'winter'), ('Feb', 'winter'), ('Mar', 'spring'),\r\n            ('Apr', 'spring'), ('May', 'summer'), ('Jun', 'summer'),\r\n            ('Jul', 'summer'), ('Aug', 'summer'), ('Sep', 'fall'),\r\n            ('Oct', 'fall'), ('Nov', 'winter'), ('Dec', 'winter')\r\n        ]\r\n\r\n        return [{\r\n            \"month\": month,\r\n            \"production\": round(base_production * factor),\r\n            \"consumption\": round(base_production * 0.9)\r\n        } for month, season in months \r\n          for factor in [seasonal_factors[season]]]\r\n\r\n    @staticmethod\r\n    def _generate_savings_timeline(annual_savings: float, system_cost: float) -> List[Dict[str, Any]]:\r\n        \"\"\"Generate 25-year savings timeline with inflation adjustment\"\"\"\r\n        return [{\r\n            \"year\": year + 1,\r\n            \"annualSavings\": round(annual_savings * (1 + (year * 0.05))),\r\n            \"cumulativeSavings\": round(annual_savings * (year + 1) * (1 + (year * 0.025)))\r\n        } for year in range(25)]"
        }
    ]
}
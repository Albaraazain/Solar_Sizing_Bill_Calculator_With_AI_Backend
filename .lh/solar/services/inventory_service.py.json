{
    "sourceFile": "solar/services/inventory_service.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 8,
            "patches": [
                {
                    "date": 1733410585056,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1733410737856,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -110,5 +110,13 @@\n                     Type='AC Cables',\r\n                     SystemRange__lte=system_size\r\n                 ).order_by('-SystemRange').first().cost),\r\n                 \r\n-                'accessories': float(Bracket\n\\ No newline at end of file\n+                'accessories': float(BracketCosts.objects.filter(\r\n+                    Type='Accessories',\r\n+                    SystemRange__lte=system_size\r\n+                ).order_by('-SystemRange').first().cost)\r\n+            }\r\n+        except (BracketCosts.DoesNotExist, AttributeError) as e:\r\n+            cls.handle_error(e, 'NOT_FOUND', 'Missing bracket costs configuration')\r\n+        except Exception as e:\r\n+            cls.handle_error(e, 'FETCH_ERROR', 'Failed to fetch bracket costs')\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733411960958,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,122 +1,262 @@\n # solar/services/inventory_service.py\r\n-from typing import Dict, Any, List\r\n+from typing import Dict, Any, List, Optional\r\n+from decimal import Decimal\r\n from django.db import transaction\r\n from django.db.models import Q\r\n \r\n from .base_service import BaseService\r\n from ..models import Panel, Inverter, variableCosts, BracketCosts\r\n-from ..serializers.admin_serializers import PanelSerializer, InverterSerializer\r\n+from ..middleware.error_handler import AppError\r\n \r\n class InventoryService(BaseService):\r\n-    \"\"\"Service for managing panels, inverters and other inventory\"\"\"\r\n+    \"\"\"Service for managing solar system inventory and costs.\"\"\"\r\n \r\n     @classmethod\r\n-    def get_panels(cls, filters: Dict[str, Any] = None) -> List[Panel]:\r\n-        \"\"\"Get panels with optional filtering\"\"\"\r\n-        queryset = Panel.objects.all()\r\n+    def get_panels(cls, filters: Optional[Dict[str, Any]] = None) -> List[Panel]:\r\n+        \"\"\"\r\n+        Get panels with optional filtering.\r\n         \r\n-        if filters:\r\n-            if brand := filters.get('brand'):\r\n-                queryset = queryset.filter(brand__icontains=brand)\r\n-            if power_min := filters.get('power_min'):\r\n-                queryset = queryset.filter(power__gte=power_min)\r\n-            if power_max := filters.get('power_max'):\r\n-                queryset = queryset.filter(power__lte=power_max)\r\n+        Args:\r\n+            filters: Optional dict containing filter parameters\r\n+                - brand: Filter by brand name\r\n+                - power_min: Minimum power rating\r\n+                - power_max: Maximum power rating\r\n+                - available_only: Only show available panels\r\n+        \"\"\"\r\n+        try:\r\n+            queryset = Panel.objects.all()\r\n \r\n-        return queryset.order_by('-power')\r\n+            if filters:\r\n+                if brand := filters.get('brand'):\r\n+                    queryset = queryset.filter(brand__icontains=brand)\r\n+                if power_min := filters.get('power_min'):\r\n+                    queryset = queryset.filter(power__gte=power_min)\r\n+                if power_max := filters.get('power_max'):\r\n+                    queryset = queryset.filter(power__lte=power_max)\r\n+                if filters.get('available_only'):\r\n+                    queryset = queryset.filter(availability=True)\r\n \r\n+            return queryset.order_by('-power')\r\n+\r\n+        except Exception as e:\r\n+            cls.handle_error(e, 'PANEL_FETCH_ERROR', 'Failed to fetch panels')\r\n+\r\n     @classmethod\r\n-    def get_inverters(cls, filters: Dict[str, Any] = None) -> List[Inverter]:\r\n-        \"\"\"Get inverters with optional filtering\"\"\"\r\n-        queryset = Inverter.objects.all()\r\n+    def get_inverters(cls, filters: Optional[Dict[str, Any]] = None) -> List[Inverter]:\r\n+        \"\"\"\r\n+        Get inverters with optional filtering.\r\n         \r\n-        if filters:\r\n-            if brand := filters.get('brand'):\r\n-                queryset = queryset.filter(brand__icontains=brand)\r\n-            if available := filters.get('available'):\r\n-                queryset = queryset.filter(availability=available)\r\n-            if power_min := filters.get('power_min'):\r\n-                queryset = queryset.filter(power__gte=power_min)\r\n+        Args:\r\n+            filters: Optional dict containing filter parameters\r\n+                - brand: Filter by brand name\r\n+                - power_min: Minimum power rating\r\n+                - available_only: Only show available inverters\r\n+        \"\"\"\r\n+        try:\r\n+            queryset = Inverter.objects.all()\r\n \r\n-        return queryset.order_by('power')\r\n+            if filters:\r\n+                if brand := filters.get('brand'):\r\n+                    queryset = queryset.filter(brand__icontains=brand)\r\n+                if power_min := filters.get('power_min'):\r\n+                    queryset = queryset.filter(power__gte=power_min)\r\n+                if filters.get('available_only'):\r\n+                    queryset = queryset.filter(availability=True)\r\n \r\n+            return queryset.order_by('power')\r\n+\r\n+        except Exception as e:\r\n+            cls.handle_error(e, 'INVERTER_FETCH_ERROR', 'Failed to fetch inverters')\r\n+\r\n     @classmethod\r\n     @transaction.atomic\r\n+    def add_panel(cls, panel_data: Dict[str, Any]) -> Panel:\r\n+        \"\"\"Add a new panel to inventory.\"\"\"\r\n+        try:\r\n+            cls.validate_data(panel_data, ['brand', 'power', 'price'])\r\n+\r\n+            # Convert decimal fields\r\n+            panel_data['power'] = Decimal(str(panel_data['power']))\r\n+            panel_data['price'] = Decimal(str(panel_data['price']))\r\n+\r\n+            panel = Panel.objects.create(**panel_data)\r\n+            return cls.format_response(panel)\r\n+\r\n+        except Exception as e:\r\n+            cls.handle_error(e, 'PANEL_CREATE_ERROR', 'Failed to create panel')\r\n+\r\n+    @classmethod\r\n+    @transaction.atomic\r\n+    def add_inverter(cls, inverter_data: Dict[str, Any]) -> Inverter:\r\n+        \"\"\"Add a new inverter to inventory.\"\"\"\r\n+        try:\r\n+            cls.validate_data(inverter_data, ['brand', 'power', 'price'])\r\n+\r\n+            # Convert decimal fields\r\n+            inverter_data['power'] = Decimal(str(inverter_data['power']))\r\n+            inverter_data['price'] = Decimal(str(inverter_data['price']))\r\n\\ No newline at end of file\n+\r\n+            inverter = Inverter.objects.create(**inverter_data)\r\n+            return cls.format_response(inverter)\r\n+\r\n+        except Exception as e:\r\n+            cls.handle_error(e, 'INVERTER_CREATE_ERROR', 'Failed to create inverter')\r\n+\r\n+    @classmethod\r\n+    @transaction.atomic\r\n+    def update_panel(cls, panel_id: int, update_data: Dict[str, Any]) -> Panel:\r\n+        \"\"\"Update panel details.\"\"\"\r\n+        try:\r\n+            panel = Panel.objects.get(id=panel_id)\r\n+\r\n+            # Convert decimal fields if present\r\n+            if 'power' in update_data:\r\n+                update_data['power'] = Decimal(str(update_data['power']))\r\n+            if 'price' in update_data:\r\n+                update_data['price'] = Decimal(str(update_data['price']))\r\n+\r\n+            for field, value in update_data.items():\r\n+                setattr(panel, field, value)\r\n+\r\n+            panel.save()\r\n+            return cls.format_response(panel)\r\n+\r\n+        except Panel.DoesNotExist:\r\n+            raise AppError(\r\n+                message=f'Panel with id {panel_id} not found',\r\n+                code='NOT_FOUND'\r\n+            )\r\n+        except Exception as e:\r\n+            cls.handle_error(e, 'PANEL_UPDATE_ERROR', 'Failed to update panel')\r\n+\r\n+    @classmethod\r\n+    @transaction.atomic\r\n+    def update_inverter(cls, inverter_id: int, update_data: Dict[str, Any]) -> Inverter:\r\n+        \"\"\"Update inverter details.\"\"\"\r\n+        try:\r\n+            inverter = Inverter.objects.get(id=inverter_id)\r\n+\r\n+            # Convert decimal fields if present\r\n+            if 'power' in update_data:\r\n+                update_data['power'] = Decimal(str(update_data['power']))\r\n+            if 'price' in update_data:\r\n+                update_data['price'] = Decimal(str(update_data['price']))\r\n+\r\n+            for field, value in update_data.items():\r\n+                setattr(inverter, field, value)\r\n+\r\n+            inverter.save()\r\n+            return cls.format_response(inverter)\r\n+\r\n+        except Inverter.DoesNotExist:\r\n+            raise AppError(\r\n+                message=f'Inverter with id {inverter_id} not found',\r\n+                code='NOT_FOUND'\r\n+            )\r\n+        except Exception as e:\r\n+            cls.handle_error(e, 'INVERTER_UPDATE_ERROR', 'Failed to update inverter')\r\n+\r\n+    @classmethod\r\n+    @transaction.atomic\r\n     def set_default_panel(cls, panel_id: int) -> Panel:\r\n-        \"\"\"Set a panel as default\"\"\"\r\n+        \"\"\"Set a panel as the default choice.\"\"\"\r\n         try:\r\n             # Reset all panels\r\n             Panel.objects.all().update(default_choice=False)\r\n-            \r\n+\r\n             # Set new default\r\n             panel = Panel.objects.get(id=panel_id)\r\n             panel.default_choice = True\r\n             panel.save()\r\n-            \r\n-            return panel\r\n-            \r\n-        except Panel.DoesNotExist as e:\r\n-            cls.handle_error(e, 'NOT_FOUND', f'Panel with id {panel_id} not found')\r\n+\r\n+            return cls.format_response(panel)\r\n+\r\n+        except Panel.DoesNotExist:\r\n+            raise AppError(\r\n+                message=f'Panel with id {panel_id} not found',\r\n+                code='NOT_FOUND'\r\n+            )\r\n         except Exception as e:\r\n-            cls.handle_error(e, 'UPDATE_ERROR', 'Failed to set default panel')\r\n+            cls.handle_error(e, 'DEFAULT_SET_ERROR', 'Failed to set default panel')\r\n \r\n     @classmethod\r\n     def get_price_configuration(cls) -> Dict[str, float]:\r\n-        \"\"\"Get current price configuration\"\"\"\r\n+        \"\"\"Get current price configuration.\"\"\"\r\n         try:\r\n-            return {\r\n-                'frame_cost_per_watt': float(variableCosts.objects.get(\r\n-                    cost_name='Frame Cost per Watt'\r\n-                ).cost),\r\n-                'installation_cost_per_watt': float(variableCosts.objects.get(\r\n-                    cost_name='Installation Cost per Watt'\r\n-                ).cost),\r\n-                'net_metering': float(variableCosts.objects.get(\r\n-                    cost_name='Net Metering'\r\n-                ).cost),\r\n-                'labor_cost': float(variableCosts.objects.get(\r\n-                    cost_name='Labor Cost'\r\n-                ).cost)\r\n-            }\r\n-        except variableCosts.DoesNotExist as e:\r\n-            cls.handle_error(e, 'NOT_FOUND', 'Incomplete cost configuration')\r\n+            costs = variableCosts.objects.all()\r\n+            return cls.format_response({\r\n+                cost.cost_name: float(cost.cost)\r\n+                for cost in costs\r\n+            })\r\n+\r\n         except Exception as e:\r\n-            cls.handle_error(e, 'FETCH_ERROR', 'Failed to fetch price configuration')\r\n+            cls.handle_error(e, 'CONFIG_FETCH_ERROR', 'Failed to fetch price configuration')\r\n \r\n     @classmethod\r\n     @transaction.atomic\r\n-    def update_price_configuration(cls, config: Dict[str, float]) -> None:\r\n-        \"\"\"Update price configuration\"\"\"\r\n+    def update_price_configuration(cls, config: Dict[str, float]) -> Dict[str, float]:\r\n+        \"\"\"Update price configuration.\"\"\"\r\n         try:\r\n-            for cost_name, value in config.items():\r\n+            for name, cost in config.items():\r\n                 variableCosts.objects.update_or_create(\r\n-                    cost_name=cost_name,\r\n-                    defaults={'cost': value}\r\n+                    cost_name=name,\r\n+                    defaults={'cost': Decimal(str(cost))}\r\n                 )\r\n+\r\n+            return cls.format_response(config)\r\n+\r\n         except Exception as e:\r\n-            cls.handle_error(e, 'UPDATE_ERROR', 'Failed to update price configuration')\r\n+            cls.handle_error(e, 'CONFIG_UPDATE_ERROR', 'Failed to update price configuration')\r\n \r\n     @classmethod\r\n     def get_bracket_costs(cls, system_size: float) -> Dict[str, float]:\r\n-        \"\"\"Get bracket costs for given system size\"\"\"\r\n+        \"\"\"Get appropriate bracket costs for system size.\"\"\"\r\n         try:\r\n-            return {\r\n-                'dc_cable': float(BracketCosts.objects.filter(\r\n-                    Type='DC Cables',\r\n+            costs = {}\r\n+            for cost_type in ['DC Cables', 'AC Cables', 'Accessories']:\r\n+                bracket = BracketCosts.objects.filter(\r\n+                    Type=cost_type,\r\n                     SystemRange__lte=system_size\r\n-                ).order_by('-SystemRange').first().cost),\r\n-                \r\n-                'ac_cable': float(BracketCosts.objects.filter(\r\n-                    Type='AC Cables',\r\n-                    SystemRange__lte=system_size\r\n-                ).order_by('-SystemRange').first().cost),\r\n-                \r\n-                'accessories': float(BracketCosts.objects.filter(\r\n-                    Type='Accessories',\r\n-                    SystemRange__lte=system_size\r\n-                ).order_by('-SystemRange').first().cost)\r\n+                ).order_by('-SystemRange').first()\r\n+\r\n+                if not bracket:\r\n+                    raise AppError(\r\n+                        message=f'No bracket cost found for {cost_type}',\r\n+                        code='NOT_FOUND',\r\n+                        data={'system_size': system_size}\r\n+                    )\r\n+\r\n+                costs[cost_type.lower().replace(' ', '_')] = float(bracket.cost)\r\n+\r\n+            return cls.format_response(costs)\r\n+\r\n+        except Exception as e:\r\n+            cls.handle_error(e, 'BRACKET_FETCH_ERROR', 'Failed to fetch bracket costs')\r\n+\r\n+    @classmethod\r\n+    def get_inventory_stats(cls) -> Dict[str, Any]:\r\n+        \"\"\"Get inventory statistics.\"\"\"\r\n+        try:\r\n+            stats = {\r\n+                'panels': {\r\n+                    'total': Panel.objects.count(),\r\n+                    'available': Panel.objects.filter(availability=True).count(),\r\n+                    'total_power': sum(\r\n+                        float(p.power) for p in Panel.objects.filter(availability=True)\r\n+                    ),\r\n+                    'brands': Panel.objects.values('brand').distinct().count()\r\n+                },\r\n+                'inverters': {\r\n+                    'total': Inverter.objects.count(),\r\n+                    'available': Inverter.objects.filter(availability=True).count(),\r\n+                    'total_power': sum(\r\n+                        float(i.power) for i in Inverter.objects.filter(availability=True)\r\n+                    ),\r\n+                    'brands': Inverter.objects.values('brand').distinct().count()\r\n+                }\r\n             }\r\n-        except (BracketCosts.DoesNotExist, AttributeError) as e:\r\n-            cls.handle_error(e, 'NOT_FOUND', 'Missing bracket costs configuration')\r\n+\r\n+            return cls.format_response(stats)\r\n+\r\n         except Exception as e:\r\n-            cls.handle_error(e, 'FETCH_ERROR', 'Failed to fetch bracket costs')\n+            cls.handle_error(e, 'STATS_ERROR', 'Failed to fetch inventory statistics')\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733412299027,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,8 +11,14 @@\n class InventoryService(BaseService):\r\n     \"\"\"Service for managing solar system inventory and costs.\"\"\"\r\n \r\n     @classmethod\r\n+    def handle_service_error(cls, e: Exception, code: str, message: str) -> None:\r\n+        \"\"\"Helper method to handle service errors consistently\"\"\"\r\n+        cls.handle_error(e, code, message)\r\n+        raise AppError(message=message, code=code, original_error=e)\r\n+\r\n+    @classmethod\r\n     def get_panels(cls, filters: Optional[Dict[str, Any]] = None) -> List[Panel]:\r\n         \"\"\"\r\n         Get panels with optional filtering.\r\n         \r\n@@ -35,12 +41,12 @@\n                     queryset = queryset.filter(power__lte=power_max)\r\n                 if filters.get('available_only'):\r\n                     queryset = queryset.filter(availability=True)\r\n \r\n-            return queryset.order_by('-power')\r\n+            return list(queryset.order_by('-power'))\r\n \r\n         except Exception as e:\r\n-            cls.handle_error(e, 'PANEL_FETCH_ERROR', 'Failed to fetch panels')\r\n+            cls.handle_service_error(e, 'PANEL_FETCH_ERROR', 'Failed to fetch panels')\r\n \r\n     @classmethod\r\n     def get_inverters(cls, filters: Optional[Dict[str, Any]] = None) -> List[Inverter]:\r\n         \"\"\"\r\n@@ -62,12 +68,12 @@\n                     queryset = queryset.filter(power__gte=power_min)\r\n                 if filters.get('available_only'):\r\n                     queryset = queryset.filter(availability=True)\r\n \r\n-            return queryset.order_by('power')\r\n+            return list(queryset.order_by('power'))\r\n \r\n         except Exception as e:\r\n-            cls.handle_error(e, 'INVERTER_FETCH_ERROR', 'Failed to fetch inverters')\r\n+            cls.handle_service_error(e, 'INVERTER_FETCH_ERROR', 'Failed to fetch inverters')\r\n \r\n     @classmethod\r\n     @transaction.atomic\r\n     def add_panel(cls, panel_data: Dict[str, Any]) -> Panel:\r\n@@ -79,12 +85,12 @@\n             panel_data['power'] = Decimal(str(panel_data['power']))\r\n             panel_data['price'] = Decimal(str(panel_data['price']))\r\n \r\n             panel = Panel.objects.create(**panel_data)\r\n-            return cls.format_response(panel)\r\n+            return panel\r\n \r\n         except Exception as e:\r\n-            cls.handle_error(e, 'PANEL_CREATE_ERROR', 'Failed to create panel')\r\n+            cls.handle_service_error(e, 'PANEL_CREATE_ERROR', 'Failed to create panel')\r\n \r\n     @classmethod\r\n     @transaction.atomic\r\n     def add_inverter(cls, inverter_data: Dict[str, Any]) -> Inverter:\r\n@@ -96,12 +102,12 @@\n             inverter_data['power'] = Decimal(str(inverter_data['power']))\r\n             inverter_data['price'] = Decimal(str(inverter_data['price']))\r\n \r\n             inverter = Inverter.objects.create(**inverter_data)\r\n-            return cls.format_response(inverter)\r\n+            return inverter\r\n \r\n         except Exception as e:\r\n-            cls.handle_error(e, 'INVERTER_CREATE_ERROR', 'Failed to create inverter')\r\n+            cls.handle_service_error(e, 'INVERTER_CREATE_ERROR', 'Failed to create inverter')\r\n \r\n     @classmethod\r\n     @transaction.atomic\r\n     def update_panel(cls, panel_id: int, update_data: Dict[str, Any]) -> Panel:\r\n@@ -118,17 +124,17 @@\n             for field, value in update_data.items():\r\n                 setattr(panel, field, value)\r\n \r\n             panel.save()\r\n-            return cls.format_response(panel)\r\n+            return panel\r\n \r\n         except Panel.DoesNotExist:\r\n             raise AppError(\r\n                 message=f'Panel with id {panel_id} not found',\r\n                 code='NOT_FOUND'\r\n             )\r\n         except Exception as e:\r\n-            cls.handle_error(e, 'PANEL_UPDATE_ERROR', 'Failed to update panel')\r\n+            cls.handle_service_error(e, 'PANEL_UPDATE_ERROR', 'Failed to update panel')\r\n \r\n     @classmethod\r\n     @transaction.atomic\r\n     def update_inverter(cls, inverter_id: int, update_data: Dict[str, Any]) -> Inverter:\r\n@@ -145,17 +151,17 @@\n             for field, value in update_data.items():\r\n                 setattr(inverter, field, value)\r\n \r\n             inverter.save()\r\n-            return cls.format_response(inverter)\r\n+            return inverter\r\n \r\n         except Inverter.DoesNotExist:\r\n             raise AppError(\r\n                 message=f'Inverter with id {inverter_id} not found',\r\n                 code='NOT_FOUND'\r\n             )\r\n         except Exception as e:\r\n-            cls.handle_error(e, 'INVERTER_UPDATE_ERROR', 'Failed to update inverter')\r\n+            cls.handle_service_error(e, 'INVERTER_UPDATE_ERROR', 'Failed to update inverter')\r\n \r\n     @classmethod\r\n     @transaction.atomic\r\n     def set_default_panel(cls, panel_id: int) -> Panel:\r\n@@ -168,30 +174,30 @@\n             panel = Panel.objects.get(id=panel_id)\r\n             panel.default_choice = True\r\n             panel.save()\r\n \r\n-            return cls.format_response(panel)\r\n+            return panel\r\n \r\n         except Panel.DoesNotExist:\r\n             raise AppError(\r\n                 message=f'Panel with id {panel_id} not found',\r\n                 code='NOT_FOUND'\r\n             )\r\n         except Exception as e:\r\n-            cls.handle_error(e, 'DEFAULT_SET_ERROR', 'Failed to set default panel')\r\n+            cls.handle_service_error(e, 'DEFAULT_SET_ERROR', 'Failed to set default panel')\r\n \r\n     @classmethod\r\n     def get_price_configuration(cls) -> Dict[str, float]:\r\n         \"\"\"Get current price configuration.\"\"\"\r\n         try:\r\n             costs = variableCosts.objects.all()\r\n-            return cls.format_response({\r\n+            return {\r\n                 cost.cost_name: float(cost.cost)\r\n                 for cost in costs\r\n-            })\r\n+            }\r\n \r\n         except Exception as e:\r\n-            cls.handle_error(e, 'CONFIG_FETCH_ERROR', 'Failed to fetch price configuration')\r\n+            cls.handle_service_error(e, 'CONFIG_FETCH_ERROR', 'Failed to fetch price configuration')\r\n \r\n     @classmethod\r\n     @transaction.atomic\r\n     def update_price_configuration(cls, config: Dict[str, float]) -> Dict[str, float]:\r\n@@ -202,12 +208,12 @@\n                     cost_name=name,\r\n                     defaults={'cost': Decimal(str(cost))}\r\n                 )\r\n \r\n-            return cls.format_response(config)\r\n+            return config\r\n \r\n         except Exception as e:\r\n-            cls.handle_error(e, 'CONFIG_UPDATE_ERROR', 'Failed to update price configuration')\r\n+            cls.handle_service_error(e, 'CONFIG_UPDATE_ERROR', 'Failed to update price configuration')\r\n \r\n     @classmethod\r\n     def get_bracket_costs(cls, system_size: float) -> Dict[str, float]:\r\n         \"\"\"Get appropriate bracket costs for system size.\"\"\"\r\n@@ -227,12 +233,12 @@\n                     )\r\n \r\n                 costs[cost_type.lower().replace(' ', '_')] = float(bracket.cost)\r\n \r\n-            return cls.format_response(costs)\r\n+            return costs\r\n \r\n         except Exception as e:\r\n-            cls.handle_error(e, 'BRACKET_FETCH_ERROR', 'Failed to fetch bracket costs')\r\n+            cls.handle_service_error(e, 'BRACKET_FETCH_ERROR', 'Failed to fetch bracket costs')\r\n \r\n     @classmethod\r\n     def get_inventory_stats(cls) -> Dict[str, Any]:\r\n         \"\"\"Get inventory statistics.\"\"\"\r\n@@ -255,8 +261,8 @@\n                     'brands': Inverter.objects.values('brand').distinct().count()\r\n                 }\r\n             }\r\n \r\n-            return cls.format_response(stats)\r\n+            return stats\r\n \r\n         except Exception as e:\r\n\\ No newline at end of file\n-            cls.handle_error(e, 'STATS_ERROR', 'Failed to fetch inventory statistics')\n+            cls.handle_service_error(e, 'STATS_ERROR', 'Failed to fetch inventory statistics')\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733431492173,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n from django.db import transaction\r\n from django.db.models import Q\r\n \r\n from .base_service import BaseService\r\n-from ..models import Panel, Inverter, variableCosts, BracketCosts\r\n+from ..models import Panel, Inverter, VariableCosts, BracketCosts\r\n from ..middleware.error_handler import AppError\r\n \r\n class InventoryService(BaseService):\r\n     \"\"\"Service for managing solar system inventory and costs.\"\"\"\r\n@@ -188,9 +188,9 @@\n     @classmethod\r\n     def get_price_configuration(cls) -> Dict[str, float]:\r\n         \"\"\"Get current price configuration.\"\"\"\r\n         try:\r\n-            costs = variableCosts.objects.all()\r\n+            costs = VariableCosts.objects.all()\r\n             return {\r\n                 cost.cost_name: float(cost.cost)\r\n                 for cost in costs\r\n             }\r\n@@ -203,9 +203,9 @@\n     def update_price_configuration(cls, config: Dict[str, float]) -> Dict[str, float]:\r\n         \"\"\"Update price configuration.\"\"\"\r\n         try:\r\n             for name, cost in config.items():\r\n-                variableCosts.objects.update_or_create(\r\n+                VariableCosts.objects.update_or_create(\r\n                     cost_name=name,\r\n                     defaults={'cost': Decimal(str(cost))}\r\n                 )\r\n \r\n"
                },
                {
                    "date": 1733431805156,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,11 +12,11 @@\n     \"\"\"Service for managing solar system inventory and costs.\"\"\"\r\n \r\n     @classmethod\r\n     def handle_service_error(cls, e: Exception, code: str, message: str) -> None:\r\n-        \"\"\"Helper method to handle service errors consistently\"\"\"\r\n+        \"\"\"Updated error handling\"\"\"\r\n         cls.handle_error(e, code, message)\r\n-        raise AppError(message=message, code=code, original_error=e)\r\n+        raise AppError(message=message, code=code, data={'original_error': str(e)}) from e\r\n \r\n     @classmethod\r\n     def get_panels(cls, filters: Optional[Dict[str, Any]] = None) -> List[Panel]:\r\n         \"\"\"\r\n@@ -45,8 +45,9 @@\n             return list(queryset.order_by('-power'))\r\n \r\n         except Exception as e:\r\n             cls.handle_service_error(e, 'PANEL_FETCH_ERROR', 'Failed to fetch panels')\r\n+            return []  # To satisfy type checker, though this line is never reached\r\n \r\n     @classmethod\r\n     def get_inverters(cls, filters: Optional[Dict[str, Any]] = None) -> List[Inverter]:\r\n         \"\"\"\r\n@@ -72,8 +73,9 @@\n             return list(queryset.order_by('power'))\r\n \r\n         except Exception as e:\r\n             cls.handle_service_error(e, 'INVERTER_FETCH_ERROR', 'Failed to fetch inverters')\r\n+            return []  # To satisfy type checker\r\n \r\n     @classmethod\r\n     @transaction.atomic\r\n     def add_panel(cls, panel_data: Dict[str, Any]) -> Panel:\r\n@@ -84,13 +86,13 @@\n             # Convert decimal fields\r\n             panel_data['power'] = Decimal(str(panel_data['power']))\r\n             panel_data['price'] = Decimal(str(panel_data['price']))\r\n \r\n-            panel = Panel.objects.create(**panel_data)\r\n-            return panel\r\n+            return Panel.objects.create(**panel_data)\r\n \r\n         except Exception as e:\r\n             cls.handle_service_error(e, 'PANEL_CREATE_ERROR', 'Failed to create panel')\r\n+            raise  # To satisfy type checker\r\n \r\n     @classmethod\r\n     @transaction.atomic\r\n     def add_inverter(cls, inverter_data: Dict[str, Any]) -> Inverter:\r\n@@ -101,13 +103,13 @@\n             # Convert decimal fields\r\n             inverter_data['power'] = Decimal(str(inverter_data['power']))\r\n             inverter_data['price'] = Decimal(str(inverter_data['price']))\r\n \r\n-            inverter = Inverter.objects.create(**inverter_data)\r\n-            return inverter\r\n+            return Inverter.objects.create(**inverter_data)\r\n \r\n         except Exception as e:\r\n             cls.handle_service_error(e, 'INVERTER_CREATE_ERROR', 'Failed to create inverter')\r\n+            raise  # To satisfy type checker\r\n \r\n     @classmethod\r\n     @transaction.atomic\r\n     def update_panel(cls, panel_id: int, update_data: Dict[str, Any]) -> Panel:\r\n@@ -219,14 +221,12 @@\n         \"\"\"Get appropriate bracket costs for system size.\"\"\"\r\n         try:\r\n             costs = {}\r\n             for cost_type in ['DC Cables', 'AC Cables', 'Accessories']:\r\n-                bracket = BracketCosts.objects.filter(\r\n+                if not (bracket := BracketCosts.objects.filter(\r\n                     Type=cost_type,\r\n                     SystemRange__lte=system_size\r\n-                ).order_by('-SystemRange').first()\r\n-\r\n-                if not bracket:\r\n+                ).order_by('-SystemRange').first()):\r\n                     raise AppError(\r\n                         message=f'No bracket cost found for {cost_type}',\r\n                         code='NOT_FOUND',\r\n                         data={'system_size': system_size}\r\n@@ -237,8 +237,9 @@\n             return costs\r\n \r\n         except Exception as e:\r\n             cls.handle_service_error(e, 'BRACKET_FETCH_ERROR', 'Failed to fetch bracket costs')\r\n+            raise  # To satisfy type checker\r\n \r\n     @classmethod\r\n     def get_inventory_stats(cls) -> Dict[str, Any]:\r\n         \"\"\"Get inventory statistics.\"\"\"\r\n"
                },
                {
                    "date": 1733431865075,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,6 @@\n # solar/services/inventory_service.py\r\n-from typing import Dict, Any, List, Optional\r\n+from typing import Dict, Any, List, Optional, NoReturn\r\n from decimal import Decimal\r\n from django.db import transaction\r\n from django.db.models import Q\r\n \r\n@@ -128,15 +128,16 @@\n \r\n             panel.save()\r\n             return panel\r\n \r\n-        except Panel.DoesNotExist:\r\n+        except Panel.DoesNotExist as e:\r\n             raise AppError(\r\n                 message=f'Panel with id {panel_id} not found',\r\n                 code='NOT_FOUND'\r\n-            )\r\n+            ) from e\r\n         except Exception as e:\r\n             cls.handle_service_error(e, 'PANEL_UPDATE_ERROR', 'Failed to update panel')\r\n+            raise  # This will never be reached but satisfies type checker\r\n \r\n     @classmethod\r\n     @transaction.atomic\r\n     def update_inverter(cls, inverter_id: int, update_data: Dict[str, Any]) -> Inverter:\r\n@@ -155,15 +156,16 @@\n \r\n             inverter.save()\r\n             return inverter\r\n \r\n-        except Inverter.DoesNotExist:\r\n+        except Inverter.DoesNotExist as e:\r\n             raise AppError(\r\n                 message=f'Inverter with id {inverter_id} not found',\r\n                 code='NOT_FOUND'\r\n-            )\r\n+            ) from e\r\n         except Exception as e:\r\n             cls.handle_service_error(e, 'INVERTER_UPDATE_ERROR', 'Failed to update inverter')\r\n+            raise  # This will never be reached but satisfies type checker\r\n \r\n     @classmethod\r\n     @transaction.atomic\r\n     def set_default_panel(cls, panel_id: int) -> Panel:\r\n@@ -178,15 +180,16 @@\n             panel.save()\r\n \r\n             return panel\r\n \r\n-        except Panel.DoesNotExist:\r\n+        except Panel.DoesNotExist as e:\r\n             raise AppError(\r\n                 message=f'Panel with id {panel_id} not found',\r\n                 code='NOT_FOUND'\r\n-            )\r\n+            ) from e\r\n         except Exception as e:\r\n             cls.handle_service_error(e, 'DEFAULT_SET_ERROR', 'Failed to set default panel')\r\n+            raise  # This will never be reached but satisfies type checker\r\n \r\n     @classmethod\r\n     def get_price_configuration(cls) -> Dict[str, float]:\r\n         \"\"\"Get current price configuration.\"\"\"\r\n@@ -198,8 +201,9 @@\n             }\r\n \r\n         except Exception as e:\r\n             cls.handle_service_error(e, 'CONFIG_FETCH_ERROR', 'Failed to fetch price configuration')\r\n+            raise  # This will never be reached but satisfies type checker\r\n \r\n     @classmethod\r\n     @transaction.atomic\r\n     def update_price_configuration(cls, config: Dict[str, float]) -> Dict[str, float]:\r\n@@ -214,8 +218,9 @@\n             return config\r\n \r\n         except Exception as e:\r\n             cls.handle_service_error(e, 'CONFIG_UPDATE_ERROR', 'Failed to update price configuration')\r\n+            raise  # This will never be reached but satisfies type checker\r\n \r\n     @classmethod\r\n     def get_bracket_costs(cls, system_size: float) -> Dict[str, float]:\r\n         \"\"\"Get appropriate bracket costs for system size.\"\"\"\r\n@@ -243,27 +248,29 @@\n     @classmethod\r\n     def get_inventory_stats(cls) -> Dict[str, Any]:\r\n         \"\"\"Get inventory statistics.\"\"\"\r\n         try:\r\n-            stats = {\r\n+            return {\r\n                 'panels': {\r\n                     'total': Panel.objects.count(),\r\n                     'available': Panel.objects.filter(availability=True).count(),\r\n                     'total_power': sum(\r\n-                        float(p.power) for p in Panel.objects.filter(availability=True)\r\n+                        float(p.power)\r\n+                        for p in Panel.objects.filter(availability=True)\r\n                     ),\r\n-                    'brands': Panel.objects.values('brand').distinct().count()\r\n+                    'brands': Panel.objects.values('brand').distinct().count(),\r\n                 },\r\n                 'inverters': {\r\n                     'total': Inverter.objects.count(),\r\n-                    'available': Inverter.objects.filter(availability=True).count(),\r\n+                    'available': Inverter.objects.filter(\r\n+                        availability=True\r\n+                    ).count(),\r\n                     'total_power': sum(\r\n-                        float(i.power) for i in Inverter.objects.filter(availability=True)\r\n+                        float(i.power)\r\n+                        for i in Inverter.objects.filter(availability=True)\r\n\\ No newline at end of file\n                     ),\r\n-                    'brands': Inverter.objects.values('brand').distinct().count()\r\n-                }\r\n+                    'brands': Inverter.objects.values('brand').distinct().count(),\r\n+                },\r\n             }\r\n-\r\n-            return stats\r\n-\r\n         except Exception as e:\r\n-            cls.handle_service_error(e, 'STATS_ERROR', 'Failed to fetch inventory statistics')\n+            cls.handle_service_error(e, 'STATS_ERROR', 'Failed to fetch inventory statistics')\r\n+            raise  # This will never be reached but satisfies type checker\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733447406416,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,13 +2,16 @@\n from typing import Dict, Any, List, Optional, NoReturn\r\n from decimal import Decimal\r\n from django.db import transaction\r\n from django.db.models import Q\r\n+import logging\r\n \r\n from .base_service import BaseService\r\n from ..models import Panel, Inverter, VariableCosts, BracketCosts\r\n from ..middleware.error_handler import AppError\r\n \r\n+logger = logging.getLogger(__name__)\r\n+\r\n class InventoryService(BaseService):\r\n     \"\"\"Service for managing solar system inventory and costs.\"\"\"\r\n \r\n     @classmethod\r\n@@ -222,29 +225,45 @@\n             raise  # This will never be reached but satisfies type checker\r\n \r\n     @classmethod\r\n     def get_bracket_costs(cls, system_size: float) -> Dict[str, float]:\r\n-        \"\"\"Get appropriate bracket costs for system size.\"\"\"\r\n+        \"\"\"Get bracket costs for given system size with error handling.\"\"\"\r\n         try:\r\n-            costs = {}\r\n-            for cost_type in ['DC Cables', 'AC Cables', 'Accessories']:\r\n-                if not (bracket := BracketCosts.objects.filter(\r\n-                    Type=cost_type,\r\n-                    SystemRange__lte=system_size\r\n-                ).order_by('-SystemRange').first()):\r\n-                    raise AppError(\r\n-                        message=f'No bracket cost found for {cost_type}',\r\n-                        code='NOT_FOUND',\r\n-                        data={'system_size': system_size}\r\n-                    )\r\n+            logger.info(f\"Fetching bracket costs for system size: {system_size}kW\")\r\n+            \r\n+            # Get the appropriate bracket cost\r\n+            bracket = BracketCosts.objects.filter(\r\n+                min_size__lte=system_size,\r\n+                max_size__gte=system_size\r\n+            ).first()\r\n \r\n-                costs[cost_type.lower().replace(' ', '_')] = float(bracket.cost)\r\n+            if not bracket:\r\n+                logger.warning(f\"No bracket found for size {system_size}kW, using default bracket\")\r\n+                # Get default bracket or create fallback values\r\n+                bracket = BracketCosts.objects.first() or BracketCosts.objects.create(\r\n+                    min_size=0,\r\n+                    max_size=999,\r\n+                    dc_cable=15000,  # Default values\r\n+                    ac_cable=10000,\r\n+                    accessories=20000\r\n+                )\r\n \r\n+            costs = {\r\n+                'dc_cable': float(bracket.dc_cable),\r\n+                'ac_cable': float(bracket.ac_cable),\r\n+                'accessories': float(bracket.accessories)\r\n+            }\r\n+            \r\n+            logger.info(f\"Retrieved costs: {costs}\")\r\n             return costs\r\n \r\n         except Exception as e:\r\n-            cls.handle_service_error(e, 'BRACKET_FETCH_ERROR', 'Failed to fetch bracket costs')\r\n-            raise  # To satisfy type checker\r\n+            logger.exception(\"Error retrieving bracket costs\")\r\n+            raise AppError(\r\n+                message='Failed to retrieve bracket costs',\r\n+                code='COST_ERROR',\r\n+                data={'error': str(e), 'system_size': system_size}\r\n+            )\r\n \r\n     @classmethod\r\n     def get_inventory_stats(cls) -> Dict[str, Any]:\r\n         \"\"\"Get inventory statistics.\"\"\"\r\n"
                },
                {
                    "date": 1733447963401,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,318 @@\n+# solar/services/inventory_service.py\r\n+from typing import Dict, Any, List, Optional, NoReturn\r\n+from decimal import Decimal\r\n+from django.db import transaction\r\n+from django.db.models import Q\r\n+import logging\r\n+\r\n+from .base_service import BaseService\r\n+from ..models import Panel, Inverter, VariableCosts, BracketCosts\r\n+from ..middleware.error_handler import AppError\r\n+\r\n+logger = logging.getLogger(__name__)\r\n+\r\n+class InventoryService(BaseService):\r\n+    \"\"\"Service for managing solar system inventory and costs.\"\"\"\r\n+\r\n+    @classmethod\r\n+    def handle_service_error(cls, e: Exception, code: str, message: str) -> None:\r\n+        \"\"\"Updated error handling\"\"\"\r\n+        cls.handle_error(e, code, message)\r\n+        raise AppError(message=message, code=code, data={'original_error': str(e)}) from e\r\n+\r\n+    @classmethod\r\n+    def get_panels(cls, filters: Optional[Dict[str, Any]] = None) -> List[Panel]:\r\n+        \"\"\"\r\n+        Get panels with optional filtering.\r\n+        \r\n+        Args:\r\n+            filters: Optional dict containing filter parameters\r\n+                - brand: Filter by brand name\r\n+                - power_min: Minimum power rating\r\n+                - power_max: Maximum power rating\r\n+                - available_only: Only show available panels\r\n+        \"\"\"\r\n+        try:\r\n+            queryset = Panel.objects.all()\r\n+\r\n+            if filters:\r\n+                if brand := filters.get('brand'):\r\n+                    queryset = queryset.filter(brand__icontains=brand)\r\n+                if power_min := filters.get('power_min'):\r\n+                    queryset = queryset.filter(power__gte=power_min)\r\n+                if power_max := filters.get('power_max'):\r\n+                    queryset = queryset.filter(power__lte=power_max)\r\n+                if filters.get('available_only'):\r\n+                    queryset = queryset.filter(availability=True)\r\n+\r\n+            return list(queryset.order_by('-power'))\r\n+\r\n+        except Exception as e:\r\n+            cls.handle_service_error(e, 'PANEL_FETCH_ERROR', 'Failed to fetch panels')\r\n+            return []  # To satisfy type checker, though this line is never reached\r\n+\r\n+    @classmethod\r\n+    def get_inverters(cls, filters: Optional[Dict[str, Any]] = None) -> List[Inverter]:\r\n+        \"\"\"\r\n+        Get inverters with optional filtering.\r\n+        \r\n+        Args:\r\n+            filters: Optional dict containing filter parameters\r\n+                - brand: Filter by brand name\r\n+                - power_min: Minimum power rating\r\n+                - available_only: Only show available inverters\r\n+        \"\"\"\r\n+        try:\r\n+            queryset = Inverter.objects.all()\r\n+\r\n+            if filters:\r\n+                if brand := filters.get('brand'):\r\n+                    queryset = queryset.filter(brand__icontains=brand)\r\n+                if power_min := filters.get('power_min'):\r\n+                    queryset = queryset.filter(power__gte=power_min)\r\n+                if filters.get('available_only'):\r\n+                    queryset = queryset.filter(availability=True)\r\n+\r\n+            return list(queryset.order_by('power'))\r\n+\r\n+        except Exception as e:\r\n+            cls.handle_service_error(e, 'INVERTER_FETCH_ERROR', 'Failed to fetch inverters')\r\n+            return []  # To satisfy type checker\r\n+\r\n+    @classmethod\r\n+    @transaction.atomic\r\n+    def add_panel(cls, panel_data: Dict[str, Any]) -> Panel:\r\n+        \"\"\"Add a new panel to inventory.\"\"\"\r\n+        try:\r\n+            cls.validate_data(panel_data, ['brand', 'power', 'price'])\r\n+\r\n+            # Convert decimal fields\r\n+            panel_data['power'] = Decimal(str(panel_data['power']))\r\n+            panel_data['price'] = Decimal(str(panel_data['price']))\r\n+\r\n+            return Panel.objects.create(**panel_data)\r\n+\r\n+        except Exception as e:\r\n+            cls.handle_service_error(e, 'PANEL_CREATE_ERROR', 'Failed to create panel')\r\n+            raise  # To satisfy type checker\r\n+\r\n+    @classmethod\r\n+    @transaction.atomic\r\n+    def add_inverter(cls, inverter_data: Dict[str, Any]) -> Inverter:\r\n+        \"\"\"Add a new inverter to inventory.\"\"\"\r\n+        try:\r\n+            cls.validate_data(inverter_data, ['brand', 'power', 'price'])\r\n+\r\n+            # Convert decimal fields\r\n+            inverter_data['power'] = Decimal(str(inverter_data['power']))\r\n+            inverter_data['price'] = Decimal(str(inverter_data['price']))\r\n+\r\n+            return Inverter.objects.create(**inverter_data)\r\n+\r\n+        except Exception as e:\r\n+            cls.handle_service_error(e, 'INVERTER_CREATE_ERROR', 'Failed to create inverter')\r\n+            raise  # To satisfy type checker\r\n+\r\n+    @classmethod\r\n+    @transaction.atomic\r\n+    def update_panel(cls, panel_id: int, update_data: Dict[str, Any]) -> Panel:\r\n+        \"\"\"Update panel details.\"\"\"\r\n+        try:\r\n+            panel = Panel.objects.get(id=panel_id)\r\n+\r\n+            # Convert decimal fields if present\r\n+            if 'power' in update_data:\r\n+                update_data['power'] = Decimal(str(update_data['power']))\r\n+            if 'price' in update_data:\r\n+                update_data['price'] = Decimal(str(update_data['price']))\r\n+\r\n+            for field, value in update_data.items():\r\n+                setattr(panel, field, value)\r\n+\r\n+            panel.save()\r\n+            return panel\r\n+\r\n+        except Panel.DoesNotExist as e:\r\n+            raise AppError(\r\n+                message=f'Panel with id {panel_id} not found',\r\n+                code='NOT_FOUND'\r\n+            ) from e\r\n+        except Exception as e:\r\n+            cls.handle_service_error(e, 'PANEL_UPDATE_ERROR', 'Failed to update panel')\r\n+            raise  # This will never be reached but satisfies type checker\r\n+\r\n+    @classmethod\r\n+    @transaction.atomic\r\n+    def update_inverter(cls, inverter_id: int, update_data: Dict[str, Any]) -> Inverter:\r\n+        \"\"\"Update inverter details.\"\"\"\r\n+        try:\r\n+            inverter = Inverter.objects.get(id=inverter_id)\r\n+\r\n+            # Convert decimal fields if present\r\n+            if 'power' in update_data:\r\n+                update_data['power'] = Decimal(str(update_data['power']))\r\n+            if 'price' in update_data:\r\n+                update_data['price'] = Decimal(str(update_data['price']))\r\n+\r\n+            for field, value in update_data.items():\r\n+                setattr(inverter, field, value)\r\n+\r\n+            inverter.save()\r\n+            return inverter\r\n+\r\n+        except Inverter.DoesNotExist as e:\r\n+            raise AppError(\r\n+                message=f'Inverter with id {inverter_id} not found',\r\n+                code='NOT_FOUND'\r\n+            ) from e\r\n+        except Exception as e:\r\n+            cls.handle_service_error(e, 'INVERTER_UPDATE_ERROR', 'Failed to update inverter')\r\n+            raise  # This will never be reached but satisfies type checker\r\n+\r\n+    @classmethod\r\n+    @transaction.atomic\r\n+    def set_default_panel(cls, panel_id: int) -> Panel:\r\n+        \"\"\"Set a panel as the default choice.\"\"\"\r\n+        try:\r\n+            # Reset all panels\r\n+            Panel.objects.all().update(default_choice=False)\r\n+\r\n+            # Set new default\r\n+            panel = Panel.objects.get(id=panel_id)\r\n+            panel.default_choice = True\r\n+            panel.save()\r\n+\r\n+            return panel\r\n+\r\n+        except Panel.DoesNotExist as e:\r\n+            raise AppError(\r\n+                message=f'Panel with id {panel_id} not found',\r\n+                code='NOT_FOUND'\r\n+            ) from e\r\n+        except Exception as e:\r\n+            cls.handle_service_error(e, 'DEFAULT_SET_ERROR', 'Failed to set default panel')\r\n+            raise  # This will never be reached but satisfies type checker\r\n+\r\n+    @classmethod\r\n+    def get_price_configuration(cls) -> Dict[str, float]:\r\n+        \"\"\"Get current price configuration with fallbacks.\"\"\"\r\n+        try:\r\n+            logger.info(\"Fetching price configuration\")\r\n+            costs = VariableCosts.objects.all()\r\n+            config = {}\r\n+\r\n+            # Required costs with defaults\r\n+            required_costs = {\r\n+                'Net Metering': '50000.00',\r\n+                'Installation Cost per Watt': '10.00',\r\n+                'Frame Cost per Watt': '8.00',\r\n+                'Labor Cost': '5000.00'\r\n+            }\r\n+\r\n+            # Get existing costs\r\n+            for cost in costs:\r\n+                config[cost.cost_name] = float(cost.cost)\r\n+\r\n+            # Add missing costs with defaults\r\n+            for name, default_value in required_costs.items():\r\n+                if name not in config:\r\n+                    logger.warning(f\"Missing cost configuration for {name}, using default\")\r\n+                    config[name] = float(Decimal(default_value))\r\n+\r\n+            logger.info(f\"Retrieved costs configuration: {config}\")\r\n+            return config\r\n+\r\n+        except Exception as e:\r\n+            logger.exception(\"Error fetching price configuration\")\r\n+            raise AppError(\r\n+                message='Failed to fetch price configuration',\r\n+                code='CONFIG_FETCH_ERROR',\r\n+                data={'error': str(e)}\r\n+            )\r\n+\r\n+    @classmethod\r\n+    @transaction.atomic\r\n+    def update_price_configuration(cls, config: Dict[str, float]) -> Dict[str, float]:\r\n+        \"\"\"Update price configuration.\"\"\"\r\n+        try:\r\n+            for name, cost in config.items():\r\n+                VariableCosts.objects.update_or_create(\r\n+                    cost_name=name,\r\n+                    defaults={'cost': Decimal(str(cost))}\r\n+                )\r\n+\r\n+            return config\r\n+\r\n+        except Exception as e:\r\n+            cls.handle_service_error(e, 'CONFIG_UPDATE_ERROR', 'Failed to update price configuration')\r\n+            raise  # This will never be reached but satisfies type checker\r\n+\r\n+    @classmethod\r\n+    def get_bracket_costs(cls, system_size: float) -> Dict[str, float]:\r\n+        \"\"\"Get bracket costs for given system size with error handling.\"\"\"\r\n+        try:\r\n+            logger.info(f\"Fetching bracket costs for system size: {system_size}kW\")\r\n+            \r\n+            # Get the appropriate bracket cost\r\n+            bracket = BracketCosts.objects.filter(\r\n+                min_size__lte=system_size,\r\n+                max_size__gte=system_size\r\n+            ).first()\r\n+\r\n+            if not bracket:\r\n+                logger.warning(f\"No bracket found for size {system_size}kW, using default bracket\")\r\n+                # Get default bracket or create fallback values\r\n+                bracket = BracketCosts.objects.first() or BracketCosts.objects.create(\r\n+                    min_size=0,\r\n+                    max_size=999,\r\n+                    dc_cable=15000,  # Default values\r\n+                    ac_cable=10000,\r\n+                    accessories=20000\r\n+                )\r\n+\r\n+            costs = {\r\n+                'dc_cable': float(bracket.dc_cable),\r\n+                'ac_cable': float(bracket.ac_cable),\r\n+                'accessories': float(bracket.accessories)\r\n+            }\r\n+            \r\n+            logger.info(f\"Retrieved costs: {costs}\")\r\n+            return costs\r\n+\r\n+        except Exception as e:\r\n+            logger.exception(\"Error retrieving bracket costs\")\r\n+            raise AppError(\r\n+                message='Failed to retrieve bracket costs',\r\n+                code='COST_ERROR',\r\n+                data={'error': str(e), 'system_size': system_size}\r\n+            )\r\n+\r\n+    @classmethod\r\n+    def get_inventory_stats(cls) -> Dict[str, Any]:\r\n+        \"\"\"Get inventory statistics.\"\"\"\r\n+        try:\r\n+            return {\r\n+                'panels': {\r\n+                    'total': Panel.objects.count(),\r\n+                    'available': Panel.objects.filter(availability=True).count(),\r\n+                    'total_power': sum(\r\n+                        float(p.power)\r\n+                        for p in Panel.objects.filter(availability=True)\r\n+                    ),\r\n+                    'brands': Panel.objects.values('brand').distinct().count(),\r\n+                },\r\n+                'inverters': {\r\n+                    'total': Inverter.objects.count(),\r\n+                    'available': Inverter.objects.filter(\r\n+                        availability=True\r\n+                    ).count(),\r\n+                    'total_power': sum(\r\n+                        float(i.power)\r\n+                        for i in Inverter.objects.filter(availability=True)\r\n+                    ),\r\n+                    'brands': Inverter.objects.values('brand').distinct().count(),\r\n+                },\r\n+            }\r\n+        except Exception as e:\r\n+            cls.handle_service_error(e, 'STATS_ERROR', 'Failed to fetch inventory statistics')\r\n+            raise  # This will never be reached but satisfies type checker\n\\ No newline at end of file\n"
                }
            ],
            "date": 1733410585056,
            "name": "Commit-0",
            "content": "# solar/services/inventory_service.py\r\nfrom typing import Dict, Any, List\r\nfrom django.db import transaction\r\nfrom django.db.models import Q\r\n\r\nfrom .base_service import BaseService\r\nfrom ..models import Panel, Inverter, variableCosts, BracketCosts\r\nfrom ..serializers.admin_serializers import PanelSerializer, InverterSerializer\r\n\r\nclass InventoryService(BaseService):\r\n    \"\"\"Service for managing panels, inverters and other inventory\"\"\"\r\n\r\n    @classmethod\r\n    def get_panels(cls, filters: Dict[str, Any] = None) -> List[Panel]:\r\n        \"\"\"Get panels with optional filtering\"\"\"\r\n        queryset = Panel.objects.all()\r\n        \r\n        if filters:\r\n            if brand := filters.get('brand'):\r\n                queryset = queryset.filter(brand__icontains=brand)\r\n            if power_min := filters.get('power_min'):\r\n                queryset = queryset.filter(power__gte=power_min)\r\n            if power_max := filters.get('power_max'):\r\n                queryset = queryset.filter(power__lte=power_max)\r\n\r\n        return queryset.order_by('-power')\r\n\r\n    @classmethod\r\n    def get_inverters(cls, filters: Dict[str, Any] = None) -> List[Inverter]:\r\n        \"\"\"Get inverters with optional filtering\"\"\"\r\n        queryset = Inverter.objects.all()\r\n        \r\n        if filters:\r\n            if brand := filters.get('brand'):\r\n                queryset = queryset.filter(brand__icontains=brand)\r\n            if available := filters.get('available'):\r\n                queryset = queryset.filter(availability=available)\r\n            if power_min := filters.get('power_min'):\r\n                queryset = queryset.filter(power__gte=power_min)\r\n\r\n        return queryset.order_by('power')\r\n\r\n    @classmethod\r\n    @transaction.atomic\r\n    def set_default_panel(cls, panel_id: int) -> Panel:\r\n        \"\"\"Set a panel as default\"\"\"\r\n        try:\r\n            # Reset all panels\r\n            Panel.objects.all().update(default_choice=False)\r\n            \r\n            # Set new default\r\n            panel = Panel.objects.get(id=panel_id)\r\n            panel.default_choice = True\r\n            panel.save()\r\n            \r\n            return panel\r\n            \r\n        except Panel.DoesNotExist as e:\r\n            cls.handle_error(e, 'NOT_FOUND', f'Panel with id {panel_id} not found')\r\n        except Exception as e:\r\n            cls.handle_error(e, 'UPDATE_ERROR', 'Failed to set default panel')\r\n\r\n    @classmethod\r\n    def get_price_configuration(cls) -> Dict[str, float]:\r\n        \"\"\"Get current price configuration\"\"\"\r\n        try:\r\n            return {\r\n                'frame_cost_per_watt': float(variableCosts.objects.get(\r\n                    cost_name='Frame Cost per Watt'\r\n                ).cost),\r\n                'installation_cost_per_watt': float(variableCosts.objects.get(\r\n                    cost_name='Installation Cost per Watt'\r\n                ).cost),\r\n                'net_metering': float(variableCosts.objects.get(\r\n                    cost_name='Net Metering'\r\n                ).cost),\r\n                'labor_cost': float(variableCosts.objects.get(\r\n                    cost_name='Labor Cost'\r\n                ).cost)\r\n            }\r\n        except variableCosts.DoesNotExist as e:\r\n            cls.handle_error(e, 'NOT_FOUND', 'Incomplete cost configuration')\r\n        except Exception as e:\r\n            cls.handle_error(e, 'FETCH_ERROR', 'Failed to fetch price configuration')\r\n\r\n    @classmethod\r\n    @transaction.atomic\r\n    def update_price_configuration(cls, config: Dict[str, float]) -> None:\r\n        \"\"\"Update price configuration\"\"\"\r\n        try:\r\n            for cost_name, value in config.items():\r\n                variableCosts.objects.update_or_create(\r\n                    cost_name=cost_name,\r\n                    defaults={'cost': value}\r\n                )\r\n        except Exception as e:\r\n            cls.handle_error(e, 'UPDATE_ERROR', 'Failed to update price configuration')\r\n\r\n    @classmethod\r\n    def get_bracket_costs(cls, system_size: float) -> Dict[str, float]:\r\n        \"\"\"Get bracket costs for given system size\"\"\"\r\n        try:\r\n            return {\r\n                'dc_cable': float(BracketCosts.objects.filter(\r\n                    Type='DC Cables',\r\n                    SystemRange__lte=system_size\r\n                ).order_by('-SystemRange').first().cost),\r\n                \r\n                'ac_cable': float(BracketCosts.objects.filter(\r\n                    Type='AC Cables',\r\n                    SystemRange__lte=system_size\r\n                ).order_by('-SystemRange').first().cost),\r\n                \r\n                'accessories': float(Bracket"
        }
    ]
}
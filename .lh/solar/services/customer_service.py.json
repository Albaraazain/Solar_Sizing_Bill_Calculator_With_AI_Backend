{
    "sourceFile": "solar/services/customer_service.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1733412299019,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1733431451713,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,285 @@\n+# solar/services/customer_service.py\r\n+from typing import Dict, Any, List, Optional, NoReturn\r\n+from django.db import transaction\r\n+from django.db.models import Q, Count\r\n+from django.core.paginator import Paginator\r\n+from datetime import datetime, timedelta\r\n+\r\n+from .base_service import BaseService\r\n+from ..models import PotentialCustomers\r\n+from ..middleware.error_handler import AppError\r\n+\r\n+class CustomerService(BaseService):\r\n+    \"\"\"Service for managing potential customers and their data.\"\"\"\r\n+\r\n+    REQUIRED_CUSTOMER_FIELDS = ['name', 'phone', 'address', 'reference_number']\r\n+\r\n+    @classmethod\r\n+    def handle_error(cls, error: Exception, code: str, message: str) -> NoReturn:\r\n+        \"\"\"\r\n+        Handle errors by raising AppError.\r\n+        Always raises an exception, never returns.\r\n+        \"\"\"\r\n+        if isinstance(error, AppError):\r\n+            raise error\r\n+        raise AppError(\r\n+            message=message or str(error),\r\n+            code=code,\r\n+            data={'original_error': str(error)}\r\n+        )\r\n+\r\n+    @classmethod\r\n+    def add_customer(cls, customer_data: Dict[str, Any]) -> Dict[str, Any]:\r\n+        \"\"\"\r\n+        Add a new potential customer.\r\n+        \r\n+        Args:\r\n+            customer_data: Dictionary containing customer information\r\n+            \r\n+        Returns:\r\n+            Dict containing saved customer data\r\n+            \r\n+        Raises:\r\n+            AppError: If validation fails or save fails\r\n+        \"\"\"\r\n+        try:\r\n+            # Validate required fields\r\n+            cls.validate_data(customer_data, cls.REQUIRED_CUSTOMER_FIELDS)\r\n+\r\n+            # Check for existing customer with same reference number\r\n+            if PotentialCustomers.objects.filter(\r\n+                reference_number=customer_data['reference_number']\r\n+            ).exists():\r\n+                raise AppError(\r\n+                    message='Customer with this reference number already exists',\r\n+                    code='DUPLICATE_ERROR'\r\n+                )\r\n+\r\n+            # Create new customer\r\n+            customer = PotentialCustomers.objects.create(\r\n+                name=customer_data['name'],\r\n+                phone=customer_data['phone'],\r\n+                address=customer_data['address'],\r\n+                reference_number=customer_data['reference_number']\r\n+            )\r\n+\r\n+            return cls.format_response({\r\n+                'id': customer.id,\r\n+                'name': customer.name,\r\n+                'phone': customer.phone,\r\n+                'address': customer.address,\r\n+                'reference_number': customer.reference_number,\r\n+                'date': customer.date\r\n+            })\r\n+\r\n+        except Exception as e:\r\n+            cls.handle_error(e, 'CUSTOMER_CREATE_ERROR', 'Failed to create customer')\r\n+\r\n+    @classmethod\r\n+    def get_customers(\r\n+        cls,\r\n+        search_query: Optional[str] = None,\r\n+        page: int = 1,\r\n+        page_size: int = 10,\r\n+        sort_by: str = '-date'\r\n+    ) -> Dict[str, Any]:\r\n+        \"\"\"\r\n+        Get paginated list of customers with optional filtering.\r\n+        \r\n+        Args:\r\n+            search_query: Optional search term for filtering\r\n+            page: Page number for pagination\r\n+            page_size: Number of items per page\r\n+            sort_by: Field to sort by (prefix with - for descending)\r\n+            \r\n+        Returns:\r\n+            Dict containing paginated customer list and metadata\r\n+        \"\"\"\r\n+        try:\r\n+            queryset = PotentialCustomers.objects.all()\r\n+\r\n+            # Apply search filter if provided\r\n+            if search_query:\r\n+                queryset = queryset.filter(\r\n+                    Q(name__icontains=search_query) |\r\n+                    Q(phone__icontains=search_query) |\r\n+                    Q(reference_number__icontains=search_query) |\r\n+                    Q(address__icontains=search_query)\r\n+                )\r\n+\r\n+            # Apply sorting\r\n+            queryset = queryset.order_by(sort_by)\r\n+\r\n+            # Paginate results\r\n+            paginator = Paginator(queryset, page_size)\r\n+            current_page = paginator.get_page(page)\r\n+\r\n+            return cls.format_response({\r\n+                'customers': [{\r\n+                    'id': customer.id,\r\n+                    'name': customer.name,\r\n+                    'phone': customer.phone,\r\n+                    'address': customer.address,\r\n+                    'reference_number': customer.reference_number,\r\n+                    'date': customer.date\r\n+                } for customer in current_page],\r\n+                'pagination': {\r\n+                    'current_page': page,\r\n+                    'total_pages': paginator.num_pages,\r\n+                    'total_items': paginator.count,\r\n+                    'has_next': current_page.has_next(),\r\n+                    'has_previous': current_page.has_previous()\r\n+                }\r\n+            })\r\n+\r\n+        except Exception as e:\r\n+            cls.handle_error(e, 'CUSTOMER_FETCH_ERROR', 'Failed to fetch customers')\r\n+\r\n+    @classmethod\r\n+    def get_customer_by_reference(cls, reference_number: str) -> Dict[str, Any]:\r\n+        \"\"\"\r\n+        Get customer details by bill reference number.\r\n+        \r\n+        Args:\r\n+            reference_number: Bill reference number\r\n+            \r\n+        Returns:\r\n+            Dict containing customer details\r\n+            \r\n+        Raises:\r\n+            AppError: If customer not found\r\n+        \"\"\"\r\n+        try:\r\n+            customer = PotentialCustomers.objects.get(\r\n+                reference_number=reference_number\r\n+            )\r\n+\r\n+            return cls.format_response({\r\n+                'id': customer.id,\r\n+                'name': customer.name,\r\n+                'phone': customer.phone,\r\n+                'address': customer.address,\r\n+                'reference_number': customer.reference_number,\r\n+                'date': customer.date\r\n+            })\r\n+\r\n+        except PotentialCustomers.DoesNotExist:\r\n+            raise AppError(\r\n+                message=f'Customer with reference {reference_number} not found',\r\n+                code='NOT_FOUND'\r\n+            )\r\n+        except Exception as e:\r\n+            cls.handle_error(e, 'CUSTOMER_FETCH_ERROR', 'Failed to fetch customer')\r\n+\r\n+    @classmethod\r\n+    def update_customer(\r\n+        cls,\r\n+        customer_id: int,\r\n+        update_data: Dict[str, Any]\r\n+    ) -> Dict[str, Any]:\r\n+        \"\"\"\r\n+        Update customer information.\r\n+        \r\n+        Args:\r\n+            customer_id: ID of customer to update\r\n+            update_data: Dictionary containing fields to update\r\n+            \r\n+        Returns:\r\n+            Dict containing updated customer data\r\n+            \r\n+        Raises:\r\n+            AppError: If customer not found or update fails\r\n+        \"\"\"\r\n+        try:\r\n+            customer = PotentialCustomers.objects.get(id=customer_id)\r\n+\r\n+            # Update provided fields\r\n+            for field, value in update_data.items():\r\n+                if hasattr(customer, field):\r\n+                    setattr(customer, field, value)\r\n+\r\n+            customer.save()\r\n+\r\n+            return cls.format_response({\r\n+                'id': customer.id,\r\n+                'name': customer.name,\r\n+                'phone': customer.phone,\r\n+                'address': customer.address,\r\n+                'reference_number': customer.reference_number,\r\n+                'date': customer.date\r\n+            })\r\n+\r\n+        except PotentialCustomers.DoesNotExist:\r\n+            raise AppError(\r\n+                message=f'Customer with id {customer_id} not found',\r\n+                code='NOT_FOUND'\r\n+            )\r\n+        except Exception as e:\r\n+            cls.handle_error(e, 'CUSTOMER_UPDATE_ERROR', 'Failed to update customer')\r\n+\r\n+    @classmethod\r\n+    def get_customer_stats(cls) -> Dict[str, Any]:\r\n+        \"\"\"Get customer statistics and metrics.\"\"\"\r\n+        try:\r\n+            total_customers = PotentialCustomers.objects.count()\r\n+            recent_customers = PotentialCustomers.objects.filter(\r\n+                date__gte=datetime.now() - timedelta(days=30)\r\n+            ).count()\r\n+\r\n+            monthly_stats = PotentialCustomers.objects.extra(\r\n+                select={'month': \"EXTRACT(month FROM date)\"}\r\n+            ).values('month').annotate(\r\n+                count=Count('id')\r\n+            ).order_by('month')\r\n+\r\n+            return cls.format_response({\r\n+                'total_customers': total_customers,\r\n+                'recent_customers': recent_customers,\r\n+                'monthly_trend': [{\r\n+                    'month': stat['month'],\r\n+                    'count': stat['count']\r\n+                } for stat in monthly_stats]\r\n+            })\r\n+\r\n+        except Exception as e:\r\n+            cls.handle_error(e, 'STATS_ERROR', 'Failed to fetch customer statistics')\r\n+\r\n+    @classmethod\r\n+    @transaction.atomic\r\n+    def bulk_create_customers(cls, customers_data: List[Dict[str, Any]]) -> Dict[str, Any]:\r\n+        \"\"\"\r\n+        Bulk create multiple customers.\r\n+        \r\n+        Args:\r\n+            customers_data: List of dictionaries containing customer data\r\n+            \r\n+        Returns:\r\n+            Dict containing creation results\r\n+            \r\n+        Raises:\r\n+            AppError: If validation fails or creation fails\r\n+        \"\"\"\r\n+        try:\r\n+            # Validate all customers first\r\n+            for customer_data in customers_data:\r\n+                cls.validate_data(customer_data, cls.REQUIRED_CUSTOMER_FIELDS)\r\n+\r\n+            # Create customers\r\n+            customers = [\r\n+                PotentialCustomers(**customer_data)\r\n+                for customer_data in customers_data\r\n+            ]\r\n+            \r\n+            created_customers = PotentialCustomers.objects.bulk_create(customers)\r\n+\r\n+            return cls.format_response({\r\n+                'created_count': len(created_customers),\r\n+                'customers': [{\r\n+                    'id': customer.id,\r\n+                    'name': customer.name,\r\n+                    'reference_number': customer.reference_number\r\n+                } for customer in created_customers]\r\n+            })\r\n+\r\n+        except Exception as e:\r\n+            cls.handle_error(e, 'BULK_CREATE_ERROR', 'Failed to create customers')\n\\ No newline at end of file\n"
                }
            ],
            "date": 1733412299019,
            "name": "Commit-0",
            "content": "# solar/services/customer_service.py\r\nfrom typing import Dict, Any, List, Optional\r\nfrom django.db import transaction\r\nfrom django.db.models import Q, Count\r\nfrom django.core.paginator import Paginator\r\nfrom datetime import datetime, timedelta\r\n\r\nfrom .base_service import BaseService\r\nfrom ..models import PotentialCustomers\r\nfrom ..middleware.error_handler import AppError\r\n\r\nclass CustomerService(BaseService):\r\n    \"\"\"Service for managing potential customers and their data.\"\"\"\r\n\r\n    REQUIRED_CUSTOMER_FIELDS = ['name', 'phone', 'address', 'reference_number']\r\n\r\n    @classmethod\r\n    def add_customer(cls, customer_data: Dict[str, Any]) -> Dict[str, Any]:\r\n        \"\"\"\r\n        Add a new potential customer.\r\n        \r\n        Args:\r\n            customer_data: Dictionary containing customer information\r\n            \r\n        Returns:\r\n            Dict containing saved customer data\r\n            \r\n        Raises:\r\n            AppError: If validation fails or save fails\r\n        \"\"\"\r\n        try:\r\n            # Validate required fields\r\n            cls.validate_data(customer_data, cls.REQUIRED_CUSTOMER_FIELDS)\r\n\r\n            # Check for existing customer with same reference number\r\n            if PotentialCustomers.objects.filter(\r\n                reference_number=customer_data['reference_number']\r\n            ).exists():\r\n                raise AppError(\r\n                    message='Customer with this reference number already exists',\r\n                    code='DUPLICATE_ERROR'\r\n                )\r\n\r\n            # Create new customer\r\n            customer = PotentialCustomers.objects.create(\r\n                name=customer_data['name'],\r\n                phone=customer_data['phone'],\r\n                address=customer_data['address'],\r\n                reference_number=customer_data['reference_number']\r\n            )\r\n\r\n            return cls.format_response({\r\n                'id': customer.id,\r\n                'name': customer.name,\r\n                'phone': customer.phone,\r\n                'address': customer.address,\r\n                'reference_number': customer.reference_number,\r\n                'date': customer.date\r\n            })\r\n\r\n        except Exception as e:\r\n            cls.handle_error(e, 'CUSTOMER_CREATE_ERROR', 'Failed to create customer')\r\n\r\n    @classmethod\r\n    def get_customers(\r\n        cls,\r\n        search_query: Optional[str] = None,\r\n        page: int = 1,\r\n        page_size: int = 10,\r\n        sort_by: str = '-date'\r\n    ) -> Dict[str, Any]:\r\n        \"\"\"\r\n        Get paginated list of customers with optional filtering.\r\n        \r\n        Args:\r\n            search_query: Optional search term for filtering\r\n            page: Page number for pagination\r\n            page_size: Number of items per page\r\n            sort_by: Field to sort by (prefix with - for descending)\r\n            \r\n        Returns:\r\n            Dict containing paginated customer list and metadata\r\n        \"\"\"\r\n        try:\r\n            queryset = PotentialCustomers.objects.all()\r\n\r\n            # Apply search filter if provided\r\n            if search_query:\r\n                queryset = queryset.filter(\r\n                    Q(name__icontains=search_query) |\r\n                    Q(phone__icontains=search_query) |\r\n                    Q(reference_number__icontains=search_query) |\r\n                    Q(address__icontains=search_query)\r\n                )\r\n\r\n            # Apply sorting\r\n            queryset = queryset.order_by(sort_by)\r\n\r\n            # Paginate results\r\n            paginator = Paginator(queryset, page_size)\r\n            current_page = paginator.get_page(page)\r\n\r\n            return cls.format_response({\r\n                'customers': [{\r\n                    'id': customer.id,\r\n                    'name': customer.name,\r\n                    'phone': customer.phone,\r\n                    'address': customer.address,\r\n                    'reference_number': customer.reference_number,\r\n                    'date': customer.date\r\n                } for customer in current_page],\r\n                'pagination': {\r\n                    'current_page': page,\r\n                    'total_pages': paginator.num_pages,\r\n                    'total_items': paginator.count,\r\n                    'has_next': current_page.has_next(),\r\n                    'has_previous': current_page.has_previous()\r\n                }\r\n            })\r\n\r\n        except Exception as e:\r\n            cls.handle_error(e, 'CUSTOMER_FETCH_ERROR', 'Failed to fetch customers')\r\n\r\n    @classmethod\r\n    def get_customer_by_reference(cls, reference_number: str) -> Dict[str, Any]:\r\n        \"\"\"\r\n        Get customer details by bill reference number.\r\n        \r\n        Args:\r\n            reference_number: Bill reference number\r\n            \r\n        Returns:\r\n            Dict containing customer details\r\n            \r\n        Raises:\r\n            AppError: If customer not found\r\n        \"\"\"\r\n        try:\r\n            customer = PotentialCustomers.objects.get(\r\n                reference_number=reference_number\r\n            )\r\n\r\n            return cls.format_response({\r\n                'id': customer.id,\r\n                'name': customer.name,\r\n                'phone': customer.phone,\r\n                'address': customer.address,\r\n                'reference_number': customer.reference_number,\r\n                'date': customer.date\r\n            })\r\n\r\n        except PotentialCustomers.DoesNotExist:\r\n            raise AppError(\r\n                message=f'Customer with reference {reference_number} not found',\r\n                code='NOT_FOUND'\r\n            )\r\n        except Exception as e:\r\n            cls.handle_error(e, 'CUSTOMER_FETCH_ERROR', 'Failed to fetch customer')\r\n\r\n    @classmethod\r\n    def update_customer(\r\n        cls,\r\n        customer_id: int,\r\n        update_data: Dict[str, Any]\r\n    ) -> Dict[str, Any]:\r\n        \"\"\"\r\n        Update customer information.\r\n        \r\n        Args:\r\n            customer_id: ID of customer to update\r\n            update_data: Dictionary containing fields to update\r\n            \r\n        Returns:\r\n            Dict containing updated customer data\r\n            \r\n        Raises:\r\n            AppError: If customer not found or update fails\r\n        \"\"\"\r\n        try:\r\n            customer = PotentialCustomers.objects.get(id=customer_id)\r\n\r\n            # Update provided fields\r\n            for field, value in update_data.items():\r\n                if hasattr(customer, field):\r\n                    setattr(customer, field, value)\r\n\r\n            customer.save()\r\n\r\n            return cls.format_response({\r\n                'id': customer.id,\r\n                'name': customer.name,\r\n                'phone': customer.phone,\r\n                'address': customer.address,\r\n                'reference_number': customer.reference_number,\r\n                'date': customer.date\r\n            })\r\n\r\n        except PotentialCustomers.DoesNotExist:\r\n            raise AppError(\r\n                message=f'Customer with id {customer_id} not found',\r\n                code='NOT_FOUND'\r\n            )\r\n        except Exception as e:\r\n            cls.handle_error(e, 'CUSTOMER_UPDATE_ERROR', 'Failed to update customer')\r\n\r\n    @classmethod\r\n    def get_customer_stats(cls) -> Dict[str, Any]:\r\n        \"\"\"Get customer statistics and metrics.\"\"\"\r\n        try:\r\n            total_customers = PotentialCustomers.objects.count()\r\n            recent_customers = PotentialCustomers.objects.filter(\r\n                date__gte=datetime.now() - timedelta(days=30)\r\n            ).count()\r\n\r\n            monthly_stats = PotentialCustomers.objects.extra(\r\n                select={'month': \"EXTRACT(month FROM date)\"}\r\n            ).values('month').annotate(\r\n                count=Count('id')\r\n            ).order_by('month')\r\n\r\n            return cls.format_response({\r\n                'total_customers': total_customers,\r\n                'recent_customers': recent_customers,\r\n                'monthly_trend': [{\r\n                    'month': stat['month'],\r\n                    'count': stat['count']\r\n                } for stat in monthly_stats]\r\n            })\r\n\r\n        except Exception as e:\r\n            cls.handle_error(e, 'STATS_ERROR', 'Failed to fetch customer statistics')\r\n\r\n    @classmethod\r\n    @transaction.atomic\r\n    def bulk_create_customers(cls, customers_data: List[Dict[str, Any]]) -> Dict[str, Any]:\r\n        \"\"\"\r\n        Bulk create multiple customers.\r\n        \r\n        Args:\r\n            customers_data: List of dictionaries containing customer data\r\n            \r\n        Returns:\r\n            Dict containing creation results\r\n            \r\n        Raises:\r\n            AppError: If validation fails or creation fails\r\n        \"\"\"\r\n        try:\r\n            # Validate all customers first\r\n            for customer_data in customers_data:\r\n                cls.validate_data(customer_data, cls.REQUIRED_CUSTOMER_FIELDS)\r\n\r\n            # Create customers\r\n            customers = [\r\n                PotentialCustomers(**customer_data)\r\n                for customer_data in customers_data\r\n            ]\r\n            \r\n            created_customers = PotentialCustomers.objects.bulk_create(customers)\r\n\r\n            return cls.format_response({\r\n                'created_count': len(created_customers),\r\n                'customers': [{\r\n                    'id': customer.id,\r\n                    'name': customer.name,\r\n                    'reference_number': customer.reference_number\r\n                } for customer in created_customers]\r\n            })\r\n\r\n        except Exception as e:\r\n            cls.handle_error(e, 'BULK_CREATE_ERROR', 'Failed to create customers')"
        }
    ]
}
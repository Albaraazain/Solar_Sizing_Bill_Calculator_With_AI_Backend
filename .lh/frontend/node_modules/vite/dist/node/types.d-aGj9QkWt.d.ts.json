{
    "sourceFile": "frontend/node_modules/vite/dist/node/types.d-aGj9QkWt.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1733415129517,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1733415129517,
            "name": "Commit-0",
            "content": "import { ModuleNamespace, ViteHotContext } from 'vite/types/hot.js';\nimport { Update, HMRPayload } from 'vite/types/hmrPayload.js';\nimport { InferCustomEventPayload } from 'vite/types/customEvent.js';\n\ntype CustomListenersMap = Map<string, ((data: any) => void)[]>;\ninterface HotModule {\n    id: string;\n    callbacks: HotCallback[];\n}\ninterface HotCallback {\n    deps: string[];\n    fn: (modules: Array<ModuleNamespace | undefined>) => void;\n}\ninterface HMRLogger {\n    error(msg: string | Error): void;\n    debug(...msg: unknown[]): void;\n}\ninterface HMRConnection {\n    /**\n     * Checked before sending messages to the client.\n     */\n    isReady(): boolean;\n    /**\n     * Send message to the client.\n     */\n    send(messages: string): void;\n}\ndeclare class HMRMessenger {\n    private connection;\n    constructor(connection: HMRConnection);\n    private queue;\n    send(message: string): void;\n    flush(): void;\n}\ndeclare class HMRClient {\n    logger: HMRLogger;\n    private importUpdatedModule;\n    hotModulesMap: Map<string, HotModule>;\n    disposeMap: Map<string, (data: any) => void | Promise<void>>;\n    pruneMap: Map<string, (data: any) => void | Promise<void>>;\n    dataMap: Map<string, any>;\n    customListenersMap: CustomListenersMap;\n    ctxToListenersMap: Map<string, CustomListenersMap>;\n    messenger: HMRMessenger;\n    constructor(logger: HMRLogger, connection: HMRConnection, importUpdatedModule: (update: Update) => Promise<ModuleNamespace>);\n    notifyListeners<T extends string>(event: T, data: InferCustomEventPayload<T>): Promise<void>;\n    clear(): void;\n    prunePaths(paths: string[]): Promise<void>;\n    protected warnFailedUpdate(err: Error, path: string | string[]): void;\n    private updateQueue;\n    private pendingUpdateQueue;\n    /**\n     * buffer multiple hot updates triggered by the same src change\n     * so that they are invoked in the same order they were sent.\n     * (otherwise the order may be inconsistent because of the http request round trip)\n     */\n    queueUpdate(payload: Update): Promise<void>;\n    private fetchUpdate;\n}\n\ninterface DefineImportMetadata {\n    /**\n     * Imported names before being transformed to `ssrImportKey`\n     *\n     * import foo, { bar as baz, qux } from 'hello'\n     * => ['default', 'bar', 'qux']\n     *\n     * import * as namespace from 'world\n     * => undefined\n     */\n    importedNames?: string[];\n}\ninterface SSRImportBaseMetadata extends DefineImportMetadata {\n    isDynamicImport?: boolean;\n}\n\ninterface SourceMapLike {\n    version: number;\n    mappings?: string;\n    names?: string[];\n    sources?: string[];\n    sourcesContent?: string[];\n}\ndeclare class DecodedMap {\n    map: SourceMapLike;\n    _encoded: string;\n    _decoded: undefined | number[][][];\n    _decodedMemo: Stats;\n    url: string;\n    version: number;\n    names: string[];\n    resolvedSources: string[];\n    constructor(map: SourceMapLike, from: string);\n}\ninterface Stats {\n    lastKey: number;\n    lastNeedle: number;\n    lastIndex: number;\n}\n\ndeclare class ModuleCacheMap extends Map<string, ModuleCache> {\n    private root;\n    constructor(root: string, entries?: [string, ModuleCache][]);\n    normalize(fsPath: string): string;\n    /**\n     * Assign partial data to the map\n     */\n    update(fsPath: string, mod: ModuleCache): this;\n    setByModuleId(modulePath: string, mod: ModuleCache): this;\n    set(fsPath: string, mod: ModuleCache): this;\n    getByModuleId(modulePath: string): ModuleCache;\n    get(fsPath: string): ModuleCache;\n    deleteByModuleId(modulePath: string): boolean;\n    delete(fsPath: string): boolean;\n    invalidate(id: string): void;\n    isImported({ importedId, importedBy, }: {\n        importedId: string;\n        importedBy: string;\n    }, seen?: Set<string>): boolean;\n    /**\n     * Invalidate modules that dependent on the given modules, up to the main entry\n     */\n    invalidateDepTree(ids: string[] | Set<string>, invalidated?: Set<string>): Set<string>;\n    /**\n     * Invalidate dependency modules of the given modules, down to the bottom-level dependencies\n     */\n    invalidateSubDepTree(ids: string[] | Set<string>, invalidated?: Set<string>): Set<string>;\n    getSourceMap(moduleId: string): null | DecodedMap;\n}\n\ndeclare const ssrModuleExportsKey = \"__vite_ssr_exports__\";\ndeclare const ssrImportKey = \"__vite_ssr_import__\";\ndeclare const ssrDynamicImportKey = \"__vite_ssr_dynamic_import__\";\ndeclare const ssrExportAllKey = \"__vite_ssr_exportAll__\";\ndeclare const ssrImportMetaKey = \"__vite_ssr_import_meta__\";\n\ninterface RetrieveFileHandler {\n    (path: string): string | null | undefined | false;\n}\ninterface RetrieveSourceMapHandler {\n    (path: string): null | {\n        url: string;\n        map: any;\n    };\n}\ninterface InterceptorOptions {\n    retrieveFile?: RetrieveFileHandler;\n    retrieveSourceMap?: RetrieveSourceMapHandler;\n}\n\ninterface SSRImportMetadata extends SSRImportBaseMetadata {\n    entrypoint?: boolean;\n}\ninterface HMRRuntimeConnection extends HMRConnection {\n    /**\n     * Configure how HMR is handled when this connection triggers an update.\n     * This method expects that connection will start listening for HMR updates and call this callback when it's received.\n     */\n    onUpdate(callback: (payload: HMRPayload) => void): void;\n}\ninterface ViteRuntimeImportMeta extends ImportMeta {\n    url: string;\n    env: ImportMetaEnv;\n    hot?: ViteHotContext;\n    [key: string]: any;\n}\ninterface ViteRuntimeModuleContext {\n    [ssrModuleExportsKey]: Record<string, any>;\n    [ssrImportKey]: (id: string, metadata?: DefineImportMetadata) => Promise<any>;\n    [ssrDynamicImportKey]: (id: string, options?: ImportCallOptions) => Promise<any>;\n    [ssrExportAllKey]: (obj: any) => void;\n    [ssrImportMetaKey]: ViteRuntimeImportMeta;\n}\ninterface ViteModuleRunner {\n    /**\n     * Run code that was transformed by Vite.\n     * @param context Function context\n     * @param code Transformed code\n     * @param id ID that was used to fetch the module\n     */\n    runViteModule(context: ViteRuntimeModuleContext, code: string, id: string): Promise<any>;\n    /**\n     * Run externalized module.\n     * @param file File URL to the external module\n     */\n    runExternalModule(file: string): Promise<any>;\n}\ninterface ModuleCache {\n    promise?: Promise<any>;\n    exports?: any;\n    evaluated?: boolean;\n    map?: DecodedMap;\n    meta?: FetchResult;\n    /**\n     * Module ids that imports this module\n     */\n    importers?: Set<string>;\n    imports?: Set<string>;\n}\ntype FetchResult = ExternalFetchResult | ViteFetchResult;\ninterface ExternalFetchResult {\n    /**\n     * The path to the externalized module starting with file://,\n     * by default this will be imported via a dynamic \"import\"\n     * instead of being transformed by vite and loaded with vite runtime\n     */\n    externalize: string;\n    /**\n     * Type of the module. Will be used to determine if import statement is correct.\n     * For example, if Vite needs to throw an error if variable is not actually exported\n     */\n    type?: 'module' | 'commonjs' | 'builtin' | 'network';\n}\ninterface ViteFetchResult {\n    /**\n     * Code that will be evaluated by vite runtime\n     * by default this will be wrapped in an async function\n     */\n    code: string;\n    /**\n     * File path of the module on disk.\n     * This will be resolved as import.meta.url/filename\n     */\n    file: string | null;\n}\ntype ResolvedResult = (ExternalFetchResult | ViteFetchResult) & {\n    id: string;\n};\n/**\n * @experimental\n */\ntype FetchFunction = (id: string, importer?: string) => Promise<FetchResult>;\ninterface ViteRuntimeOptions {\n    /**\n     * Root of the project\n     */\n    root: string;\n    /**\n     * A method to get the information about the module.\n     * For SSR, Vite exposes `server.ssrFetchModule` function that you can use here.\n     * For other runtime use cases, Vite also exposes `fetchModule` from its main entry point.\n     */\n    fetchModule: FetchFunction;\n    /**\n     * Custom environment variables available on `import.meta.env`. This doesn't modify the actual `process.env`.\n     */\n    environmentVariables?: Record<string, any>;\n    /**\n     * Configure how source maps are resolved. Prefers `node` if `process.setSourceMapsEnabled` is available.\n     * Otherwise it will use `prepareStackTrace` by default which overrides `Error.prepareStackTrace` method.\n     * You can provide an object to configure how file contents and source maps are resolved for files that were not processed by Vite.\n     */\n    sourcemapInterceptor?: false | 'node' | 'prepareStackTrace' | InterceptorOptions;\n    /**\n     * Disable HMR or configure HMR options.\n     */\n    hmr?: false | {\n        /**\n         * Configure how HMR communicates between the client and the server.\n         */\n        connection: HMRRuntimeConnection;\n        /**\n         * Configure HMR logger.\n         */\n        logger?: false | HMRLogger;\n    };\n    /**\n     * Custom module cache. If not provided, creates a separate module cache for each ViteRuntime instance.\n     */\n    moduleCache?: ModuleCacheMap;\n}\ninterface ImportMetaEnv {\n    [key: string]: any;\n    BASE_URL: string;\n    MODE: string;\n    DEV: boolean;\n    PROD: boolean;\n    SSR: boolean;\n}\n\nexport { type FetchResult as F, type HMRLogger as H, ModuleCacheMap as M, type ResolvedResult as R, type SSRImportMetadata as S, type ViteRuntimeOptions as V, type FetchFunction as a, type ViteModuleRunner as b, HMRClient as c, type ViteRuntimeModuleContext as d, type HMRConnection as e, type ModuleCache as f, type HMRRuntimeConnection as g, type ViteRuntimeImportMeta as h, ssrExportAllKey as i, ssrImportKey as j, ssrImportMetaKey as k, ssrModuleExportsKey as l, ssrDynamicImportKey as s };\n"
        }
    ]
}
{
    "sourceFile": "frontend/node_modules/vite/dist/node/index.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1733415129534,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1733415129534,
            "name": "Commit-0",
            "content": "/// <reference types=\"node\" />\nimport { PluginHooks, RollupError, SourceMap, ModuleInfo, PartialResolvedId, MinimalPluginContext, InputOptions, CustomPluginOptions, LoadResult, SourceDescription, RollupOptions, WatcherOptions, InputOption, ModuleFormat, RollupOutput, RollupWatcher, SourceMapInput, ExistingRawSourceMap, OutputBundle, OutputChunk, ObjectHook, PluginContext, ResolveIdResult, TransformPluginContext, GetManualChunk } from 'rollup';\nimport * as rollup from 'rollup';\nexport { rollup as Rollup };\nexport { parseAst, parseAstAsync } from 'rollup/parseAst';\nimport * as http from 'node:http';\nimport { OutgoingHttpHeaders, ClientRequestArgs, IncomingMessage, ClientRequest, Agent, Server, ServerResponse } from 'node:http';\nimport { Http2SecureServer } from 'node:http2';\nimport * as fs from 'node:fs';\nimport * as events from 'node:events';\nimport { EventEmitter } from 'node:events';\nimport { ServerOptions as HttpsServerOptions, Server as HttpsServer } from 'node:https';\nimport * as net from 'node:net';\nimport * as url from 'node:url';\nimport { URL } from 'node:url';\nimport * as stream from 'node:stream';\nimport { Duplex, DuplexOptions } from 'node:stream';\nimport { F as FetchResult, H as HMRLogger } from './types.d-aGj9QkWt.js';\nexport { a as FetchFunction } from './types.d-aGj9QkWt.js';\nimport { SecureContextOptions } from 'node:tls';\nimport { ZlibOptions } from 'node:zlib';\nimport { HMRPayload, CustomPayload } from 'vite/types/hmrPayload.js';\nexport { ConnectedPayload, CustomPayload, ErrorPayload, FullReloadPayload, HMRPayload, PrunePayload, Update, UpdatePayload } from 'vite/types/hmrPayload.js';\nimport { InferCustomEventPayload } from 'vite/types/customEvent.js';\nexport { CustomEventMap, InferCustomEventPayload, InvalidatePayload } from 'vite/types/customEvent.js';\nimport { TransformOptions as esbuild_TransformOptions, TransformResult as esbuild_TransformResult, BuildOptions as esbuild_BuildOptions } from 'esbuild';\nexport { TransformOptions as EsbuildTransformOptions, version as esbuildVersion } from 'esbuild';\nimport * as PostCSS from 'postcss';\nimport { ViteRuntimeOptions, ViteModuleRunner, ViteRuntime, HMRRuntimeConnection } from 'vite/runtime';\nexport { GeneralImportGlobOptions, ImportGlobFunction, ImportGlobOptions, KnownAsTypeMap } from 'vite/types/importGlob.js';\nexport { ChunkMetadata } from 'vite/types/metadata.js';\nimport 'vite/types/hot.js';\n\ninterface Alias {\n  find: string | RegExp\n  replacement: string\n  /**\n   * Instructs the plugin to use an alternative resolving algorithm,\n   * rather than the Rollup's resolver.\n   * @default null\n   */\n  customResolver?: ResolverFunction | ResolverObject | null\n}\n\ntype MapToFunction<T> = T extends Function ? T : never\n\ntype ResolverFunction = MapToFunction<PluginHooks['resolveId']>\n\ninterface ResolverObject {\n  buildStart?: PluginHooks['buildStart']\n  resolveId: ResolverFunction\n}\n\n/**\n * Specifies an `Object`, or an `Array` of `Object`,\n * which defines aliases used to replace values in `import` or `require` statements.\n * With either format, the order of the entries is important,\n * in that the first defined rules are applied first.\n *\n * This is passed to \\@rollup/plugin-alias as the \"entries\" field\n * https://github.com/rollup/plugins/tree/master/packages/alias#entries\n */\ntype AliasOptions = readonly Alias[] | { [find: string]: string }\n\ntype AnymatchFn = (testString: string) => boolean\ntype AnymatchPattern = string | RegExp | AnymatchFn\ntype AnymatchMatcher = AnymatchPattern | AnymatchPattern[]\n\n// Inlined to avoid extra dependency (chokidar is bundled in the published build)\n\ndeclare class FSWatcher extends EventEmitter implements fs.FSWatcher {\n  options: WatchOptions\n\n  /**\n   * Constructs a new FSWatcher instance with optional WatchOptions parameter.\n   */\n  constructor(options?: WatchOptions)\n\n  /**\n   * When called, requests that the Node.js event loop not exit so long as the fs.FSWatcher is active.\n   * Calling watcher.ref() multiple times will have no effect.\n   */\n  ref(): this\n\n  /**\n   * When called, the active fs.FSWatcher object will not require the Node.js event loop to remain active.\n   * If there is no other activity keeping the event loop running, the process may exit before the fs.FSWatcher object's callback is invoked.\n   * Calling watcher.unref() multiple times will have no effect.\n   */\n  unref(): this\n\n  /**\n   * Add files, directories, or glob patterns for tracking. Takes an array of strings or just one\n   * string.\n   */\n  add(paths: string | ReadonlyArray<string>): this\n\n  /**\n   * Stop watching files, directories, or glob patterns. Takes an array of strings or just one\n   * string.\n   */\n  unwatch(paths: string | ReadonlyArray<string>): this\n\n  /**\n   * Returns an object representing all the paths on the file system being watched by this\n   * `FSWatcher` instance. The object's keys are all the directories (using absolute paths unless\n   * the `cwd` option was used), and the values are arrays of the names of the items contained in\n   * each directory.\n   */\n  getWatched(): {\n    [directory: string]: string[]\n  }\n\n  /**\n   * Removes all listeners from watched files.\n   */\n  close(): Promise<void>\n\n  on(\n    event: 'add' | 'addDir' | 'change',\n    listener: (path: string, stats?: fs.Stats) => void,\n  ): this\n\n  on(\n    event: 'all',\n    listener: (\n      eventName: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir',\n      path: string,\n      stats?: fs.Stats,\n    ) => void,\n  ): this\n\n  /**\n   * Error occurred\n   */\n  on(event: 'error', listener: (error: Error) => void): this\n\n  /**\n   * Exposes the native Node `fs.FSWatcher events`\n   */\n  on(\n    event: 'raw',\n    listener: (eventName: string, path: string, details: any) => void,\n  ): this\n\n  /**\n   * Fires when the initial scan is complete\n   */\n  on(event: 'ready', listener: () => void): this\n\n  on(event: 'unlink' | 'unlinkDir', listener: (path: string) => void): this\n\n  on(event: string, listener: (...args: any[]) => void): this\n}\n\ninterface WatchOptions {\n  /**\n   * Indicates whether the process should continue to run as long as files are being watched. If\n   * set to `false` when using `fsevents` to watch, no more events will be emitted after `ready`,\n   * even if the process continues to run.\n   */\n  persistent?: boolean\n\n  /**\n   * ([anymatch](https://github.com/micromatch/anymatch)-compatible definition) Defines files/paths to\n   * be ignored. The whole relative or absolute path is tested, not just filename. If a function\n   * with two arguments is provided, it gets called twice per path - once with a single argument\n   * (the path), second time with two arguments (the path and the\n   * [`fs.Stats`](https://nodejs.org/api/fs.html#fs_class_fs_stats) object of that path).\n   */\n  ignored?: AnymatchMatcher\n\n  /**\n   * If set to `false` then `add`/`addDir` events are also emitted for matching paths while\n   * instantiating the watching as chokidar discovers these file paths (before the `ready` event).\n   */\n  ignoreInitial?: boolean\n\n  /**\n   * When `false`, only the symlinks themselves will be watched for changes instead of following\n   * the link references and bubbling events through the link's path.\n   */\n  followSymlinks?: boolean\n\n  /**\n   * The base directory from which watch `paths` are to be derived. Paths emitted with events will\n   * be relative to this.\n   */\n  cwd?: string\n\n  /**\n   * If set to true then the strings passed to .watch() and .add() are treated as literal path\n   * names, even if they look like globs.\n   *\n   * @default false\n   */\n  disableGlobbing?: boolean\n\n  /**\n   * Whether to use fs.watchFile (backed by polling), or fs.watch. If polling leads to high CPU\n   * utilization, consider setting this to `false`. It is typically necessary to **set this to\n   * `true` to successfully watch files over a network**, and it may be necessary to successfully\n   * watch files in other non-standard situations. Setting to `true` explicitly on OS X overrides\n   * the `useFsEvents` default.\n   */\n  usePolling?: boolean\n\n  /**\n   * Whether to use the `fsevents` watching interface if available. When set to `true` explicitly\n   * and `fsevents` is available this supersedes the `usePolling` setting. When set to `false` on\n   * OS X, `usePolling: true` becomes the default.\n   */\n  useFsEvents?: boolean\n\n  /**\n   * If relying upon the [`fs.Stats`](https://nodejs.org/api/fs.html#fs_class_fs_stats) object that\n   * may get passed with `add`, `addDir`, and `change` events, set this to `true` to ensure it is\n   * provided even in cases where it wasn't already available from the underlying watch events.\n   */\n  alwaysStat?: boolean\n\n  /**\n   * If set, limits how many levels of subdirectories will be traversed.\n   */\n  depth?: number\n\n  /**\n   * Interval of file system polling.\n   */\n  interval?: number\n\n  /**\n   * Interval of file system polling for binary files. ([see list of binary extensions](https://gi\n   * thub.com/sindresorhus/binary-extensions/blob/master/binary-extensions.json))\n   */\n  binaryInterval?: number\n\n  /**\n   *  Indicates whether to watch files that don't have read permissions if possible. If watching\n   *  fails due to `EPERM` or `EACCES` with this set to `true`, the errors will be suppressed\n   *  silently.\n   */\n  ignorePermissionErrors?: boolean\n\n  /**\n   * `true` if `useFsEvents` and `usePolling` are `false`. Automatically filters out artifacts\n   * that occur when using editors that use \"atomic writes\" instead of writing directly to the\n   * source file. If a file is re-added within 100 ms of being deleted, Chokidar emits a `change`\n   * event rather than `unlink` then `add`. If the default of 100 ms does not work well for you,\n   * you can override it by setting `atomic` to a custom value, in milliseconds.\n   */\n  atomic?: boolean | number\n\n  /**\n   * can be set to an object in order to adjust timing params:\n   */\n  awaitWriteFinish?: AwaitWriteFinishOptions | boolean\n}\n\ninterface AwaitWriteFinishOptions {\n  /**\n   * Amount of time in milliseconds for a file size to remain constant before emitting its event.\n   */\n  stabilityThreshold?: number\n\n  /**\n   * File size polling interval.\n   */\n  pollInterval?: number\n}\n\n// Inlined to avoid extra dependency\n// MIT Licensed https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/LICENSE\n\ndeclare namespace Connect {\n  export type ServerHandle = HandleFunction | http.Server\n\n  export class IncomingMessage extends http.IncomingMessage {\n    originalUrl?: http.IncomingMessage['url'] | undefined\n  }\n\n  export type NextFunction = (err?: any) => void\n\n  export type SimpleHandleFunction = (\n    req: IncomingMessage,\n    res: http.ServerResponse,\n  ) => void\n  export type NextHandleFunction = (\n    req: IncomingMessage,\n    res: http.ServerResponse,\n    next: NextFunction,\n  ) => void\n  export type ErrorHandleFunction = (\n    err: any,\n    req: IncomingMessage,\n    res: http.ServerResponse,\n    next: NextFunction,\n  ) => void\n  export type HandleFunction =\n    | SimpleHandleFunction\n    | NextHandleFunction\n    | ErrorHandleFunction\n\n  export interface ServerStackItem {\n    route: string\n    handle: ServerHandle\n  }\n\n  export interface Server extends NodeJS.EventEmitter {\n    (req: http.IncomingMessage, res: http.ServerResponse, next?: Function): void\n\n    route: string\n    stack: ServerStackItem[]\n\n    /**\n     * Utilize the given middleware `handle` to the given `route`,\n     * defaulting to _/_. This \"route\" is the mount-point for the\n     * middleware, when given a value other than _/_ the middleware\n     * is only effective when that segment is present in the request's\n     * pathname.\n     *\n     * For example if we were to mount a function at _/admin_, it would\n     * be invoked on _/admin_, and _/admin/settings_, however it would\n     * not be invoked for _/_, or _/posts_.\n     */\n    use(fn: NextHandleFunction): Server\n    use(fn: HandleFunction): Server\n    use(route: string, fn: NextHandleFunction): Server\n    use(route: string, fn: HandleFunction): Server\n\n    /**\n     * Handle server requests, punting them down\n     * the middleware stack.\n     */\n    handle(\n      req: http.IncomingMessage,\n      res: http.ServerResponse,\n      next: Function,\n    ): void\n\n    /**\n     * Listen for connections.\n     *\n     * This method takes the same arguments\n     * as node's `http.Server#listen()`.\n     *\n     * HTTP and HTTPS:\n     *\n     * If you run your application both as HTTP\n     * and HTTPS you may wrap them individually,\n     * since your Connect \"server\" is really just\n     * a JavaScript `Function`.\n     *\n     *      var connect = require('connect')\n     *        , http = require('http')\n     *        , https = require('https');\n     *\n     *      var app = connect();\n     *\n     *      http.createServer(app).listen(80);\n     *      https.createServer(options, app).listen(443);\n     */\n    listen(\n      port: number,\n      hostname?: string,\n      backlog?: number,\n      callback?: Function,\n    ): http.Server\n    listen(port: number, hostname?: string, callback?: Function): http.Server\n    listen(path: string, callback?: Function): http.Server\n    listen(handle: any, listeningListener?: Function): http.Server\n  }\n}\n\n// Inlined to avoid extra dependency\n// MIT Licensed https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/LICENSE\n\ndeclare namespace HttpProxy {\n  export type ProxyTarget = ProxyTargetUrl | ProxyTargetDetailed\n\n  export type ProxyTargetUrl = string | Partial<url.Url>\n\n  export interface ProxyTargetDetailed {\n    host: string\n    port: number\n    protocol?: string | undefined\n    hostname?: string | undefined\n    socketPath?: string | undefined\n    key?: string | undefined\n    passphrase?: string | undefined\n    pfx?: Buffer | string | undefined\n    cert?: string | undefined\n    ca?: string | undefined\n    ciphers?: string | undefined\n    secureProtocol?: string | undefined\n  }\n\n  export type ErrorCallback = (\n    err: Error,\n    req: http.IncomingMessage,\n    res: http.ServerResponse,\n    target?: ProxyTargetUrl,\n  ) => void\n\n  export class Server extends events.EventEmitter {\n    /**\n     * Creates the proxy server with specified options.\n     * @param options - Config object passed to the proxy\n     */\n    constructor(options?: ServerOptions)\n\n    /**\n     * Used for proxying regular HTTP(S) requests\n     * @param req - Client request.\n     * @param res - Client response.\n     * @param options - Additional options.\n     * @param callback - Error callback.\n     */\n    web(\n      req: http.IncomingMessage,\n      res: http.ServerResponse,\n      options?: ServerOptions,\n      callback?: ErrorCallback,\n    ): void\n\n    /**\n     * Used for proxying regular HTTP(S) requests\n     * @param req - Client request.\n     * @param socket - Client socket.\n     * @param head - Client head.\n     * @param options - Additional options.\n     * @param callback - Error callback.\n     */\n    ws(\n      req: http.IncomingMessage,\n      socket: unknown,\n      head: unknown,\n      options?: ServerOptions,\n      callback?: ErrorCallback,\n    ): void\n\n    /**\n     * A function that wraps the object in a webserver, for your convenience\n     * @param port - Port to listen on\n     */\n    listen(port: number): Server\n\n    /**\n     * A function that closes the inner webserver and stops listening on given port\n     */\n    close(callback?: () => void): void\n\n    /**\n     * Creates the proxy server with specified options.\n     * @param options - Config object passed to the proxy\n     * @returns Proxy object with handlers for `ws` and `web` requests\n     */\n    static createProxyServer(options?: ServerOptions): Server\n\n    /**\n     * Creates the proxy server with specified options.\n     * @param options - Config object passed to the proxy\n     * @returns Proxy object with handlers for `ws` and `web` requests\n     */\n    static createServer(options?: ServerOptions): Server\n\n    /**\n     * Creates the proxy server with specified options.\n     * @param options - Config object passed to the proxy\n     * @returns Proxy object with handlers for `ws` and `web` requests\n     */\n    static createProxy(options?: ServerOptions): Server\n\n    addListener(event: string, listener: () => void): this\n    on(event: string, listener: () => void): this\n    on(event: 'error', listener: ErrorCallback): this\n    on(\n      event: 'start',\n      listener: (\n        req: http.IncomingMessage,\n        res: http.ServerResponse,\n        target: ProxyTargetUrl,\n      ) => void,\n    ): this\n    on(\n      event: 'proxyReq',\n      listener: (\n        proxyReq: http.ClientRequest,\n        req: http.IncomingMessage,\n        res: http.ServerResponse,\n        options: ServerOptions,\n      ) => void,\n    ): this\n    on(\n      event: 'proxyRes',\n      listener: (\n        proxyRes: http.IncomingMessage,\n        req: http.IncomingMessage,\n        res: http.ServerResponse,\n      ) => void,\n    ): this\n    on(\n      event: 'proxyReqWs',\n      listener: (\n        proxyReq: http.ClientRequest,\n        req: http.IncomingMessage,\n        socket: net.Socket,\n        options: ServerOptions,\n        head: any,\n      ) => void,\n    ): this\n    on(\n      event: 'econnreset',\n      listener: (\n        err: Error,\n        req: http.IncomingMessage,\n        res: http.ServerResponse,\n        target: ProxyTargetUrl,\n      ) => void,\n    ): this\n    on(\n      event: 'end',\n      listener: (\n        req: http.IncomingMessage,\n        res: http.ServerResponse,\n        proxyRes: http.IncomingMessage,\n      ) => void,\n    ): this\n    on(\n      event: 'close',\n      listener: (\n        proxyRes: http.IncomingMessage,\n        proxySocket: net.Socket,\n        proxyHead: any,\n      ) => void,\n    ): this\n\n    once(event: string, listener: () => void): this\n    removeListener(event: string, listener: () => void): this\n    removeAllListeners(event?: string): this\n    getMaxListeners(): number\n    setMaxListeners(n: number): this\n    listeners(event: string): Array<() => void>\n    emit(event: string, ...args: any[]): boolean\n    listenerCount(type: string): number\n  }\n\n  export interface ServerOptions {\n    /** URL string to be parsed with the url module. */\n    target?: ProxyTarget | undefined\n    /** URL string to be parsed with the url module. */\n    forward?: ProxyTargetUrl | undefined\n    /** Object to be passed to http(s).request. */\n    agent?: any\n    /** Object to be passed to https.createServer(). */\n    ssl?: any\n    /** If you want to proxy websockets. */\n    ws?: boolean | undefined\n    /** Adds x- forward headers. */\n    xfwd?: boolean | undefined\n    /** Verify SSL certificate. */\n    secure?: boolean | undefined\n    /** Explicitly specify if we are proxying to another proxy. */\n    toProxy?: boolean | undefined\n    /** Specify whether you want to prepend the target's path to the proxy path. */\n    prependPath?: boolean | undefined\n    /** Specify whether you want to ignore the proxy path of the incoming request. */\n    ignorePath?: boolean | undefined\n    /** Local interface string to bind for outgoing connections. */\n    localAddress?: string | undefined\n    /** Changes the origin of the host header to the target URL. */\n    changeOrigin?: boolean | undefined\n    /** specify whether you want to keep letter case of response header key */\n    preserveHeaderKeyCase?: boolean | undefined\n    /** Basic authentication i.e. 'user:password' to compute an Authorization header. */\n    auth?: string | undefined\n    /** Rewrites the location hostname on (301 / 302 / 307 / 308) redirects, Default: null. */\n    hostRewrite?: string | undefined\n    /** Rewrites the location host/ port on (301 / 302 / 307 / 308) redirects based on requested host/ port.Default: false. */\n    autoRewrite?: boolean | undefined\n    /** Rewrites the location protocol on (301 / 302 / 307 / 308) redirects to 'http' or 'https'.Default: null. */\n    protocolRewrite?: string | undefined\n    /** rewrites domain of set-cookie headers. */\n    cookieDomainRewrite?:\n      | false\n      | string\n      | { [oldDomain: string]: string }\n      | undefined\n    /** rewrites path of set-cookie headers. Default: false */\n    cookiePathRewrite?:\n      | false\n      | string\n      | { [oldPath: string]: string }\n      | undefined\n    /** object with extra headers to be added to target requests. */\n    headers?: { [header: string]: string } | undefined\n    /** Timeout (in milliseconds) when proxy receives no response from target. Default: 120000 (2 minutes) */\n    proxyTimeout?: number | undefined\n    /** Timeout (in milliseconds) for incoming requests */\n    timeout?: number | undefined\n    /** Specify whether you want to follow redirects. Default: false */\n    followRedirects?: boolean | undefined\n    /** If set to true, none of the webOutgoing passes are called and it's your responsibility to appropriately return the response by listening and acting on the proxyRes event */\n    selfHandleResponse?: boolean | undefined\n    /** Buffer */\n    buffer?: stream.Stream | undefined\n  }\n}\n\ninterface ProxyOptions extends HttpProxy.ServerOptions {\n    /**\n     * rewrite path\n     */\n    rewrite?: (path: string) => string;\n    /**\n     * configure the proxy server (e.g. listen to events)\n     */\n    configure?: (proxy: HttpProxy.Server, options: ProxyOptions) => void;\n    /**\n     * webpack-dev-server style bypass function\n     */\n    bypass?: (req: http.IncomingMessage, res: http.ServerResponse, options: ProxyOptions) => void | null | undefined | false | string;\n    /**\n     * rewrite the Origin header of a WebSocket request to match the the target\n     *\n     * **Exercise caution as rewriting the Origin can leave the proxying open to [CSRF attacks](https://owasp.org/www-community/attacks/csrf).**\n     */\n    rewriteWsOrigin?: boolean | undefined;\n}\n\ntype LogType = 'error' | 'warn' | 'info';\ntype LogLevel = LogType | 'silent';\ninterface Logger {\n    info(msg: string, options?: LogOptions): void;\n    warn(msg: string, options?: LogOptions): void;\n    warnOnce(msg: string, options?: LogOptions): void;\n    error(msg: string, options?: LogErrorOptions): void;\n    clearScreen(type: LogType): void;\n    hasErrorLogged(error: Error | RollupError): boolean;\n    hasWarned: boolean;\n}\ninterface LogOptions {\n    clear?: boolean;\n    timestamp?: boolean;\n}\ninterface LogErrorOptions extends LogOptions {\n    error?: Error | RollupError | null;\n}\ninterface LoggerOptions {\n    prefix?: string;\n    allowClearScreen?: boolean;\n    customLogger?: Logger;\n}\ndeclare function createLogger(level?: LogLevel, options?: LoggerOptions): Logger;\n\ninterface CommonServerOptions {\n    /**\n     * Specify server port. Note if the port is already being used, Vite will\n     * automatically try the next available port so this may not be the actual\n     * port the server ends up listening on.\n     */\n    port?: number;\n    /**\n     * If enabled, vite will exit if specified port is already in use\n     */\n    strictPort?: boolean;\n    /**\n     * Specify which IP addresses the server should listen on.\n     * Set to 0.0.0.0 to listen on all addresses, including LAN and public addresses.\n     */\n    host?: string | boolean;\n    /**\n     * Enable TLS + HTTP/2.\n     * Note: this downgrades to TLS only when the proxy option is also used.\n     */\n    https?: HttpsServerOptions;\n    /**\n     * Open browser window on startup\n     */\n    open?: boolean | string;\n    /**\n     * Configure custom proxy rules for the dev server. Expects an object\n     * of `{ key: options }` pairs.\n     * Uses [`http-proxy`](https://github.com/http-party/node-http-proxy).\n     * Full options [here](https://github.com/http-party/node-http-proxy#options).\n     *\n     * Example `vite.config.js`:\n     * ``` js\n     * module.exports = {\n     *   proxy: {\n     *     // string shorthand: /foo -> http://localhost:4567/foo\n     *     '/foo': 'http://localhost:4567',\n     *     // with options\n     *     '/api': {\n     *       target: 'http://jsonplaceholder.typicode.com',\n     *       changeOrigin: true,\n     *       rewrite: path => path.replace(/^\\/api/, '')\n     *     }\n     *   }\n     * }\n     * ```\n     */\n    proxy?: Record<string, string | ProxyOptions>;\n    /**\n     * Configure CORS for the dev server.\n     * Uses https://github.com/expressjs/cors.\n     * Set to `true` to allow all methods from any origin, or configure separately\n     * using an object.\n     */\n    cors?: CorsOptions | boolean;\n    /**\n     * Specify server response headers.\n     */\n    headers?: OutgoingHttpHeaders;\n}\n/**\n * https://github.com/expressjs/cors#configuration-options\n */\ninterface CorsOptions {\n    origin?: CorsOrigin | ((origin: string | undefined, cb: (err: Error, origins: CorsOrigin) => void) => void);\n    methods?: string | string[];\n    allowedHeaders?: string | string[];\n    exposedHeaders?: string | string[];\n    credentials?: boolean;\n    maxAge?: number;\n    preflightContinue?: boolean;\n    optionsSuccessStatus?: number;\n}\ntype CorsOrigin = boolean | string | RegExp | (string | RegExp)[];\n\ninterface PreviewOptions extends CommonServerOptions {\n}\ninterface ResolvedPreviewOptions extends PreviewOptions {\n}\ninterface PreviewServer {\n    /**\n     * The resolved vite config object\n     */\n    config: ResolvedConfig;\n    /**\n     * Stop the server.\n     */\n    close(): Promise<void>;\n    /**\n     * A connect app instance.\n     * - Can be used to attach custom middlewares to the preview server.\n     * - Can also be used as the handler function of a custom http server\n     *   or as a middleware in any connect-style Node.js frameworks\n     *\n     * https://github.com/senchalabs/connect#use-middleware\n     */\n    middlewares: Connect.Server;\n    /**\n     * native Node http server instance\n     */\n    httpServer: HttpServer;\n    /**\n     * The resolved urls Vite prints on the CLI.\n     * null before server is listening.\n     */\n    resolvedUrls: ResolvedServerUrls | null;\n    /**\n     * Print server urls\n     */\n    printUrls(): void;\n    /**\n     * Bind CLI shortcuts\n     */\n    bindCLIShortcuts(options?: BindCLIShortcutsOptions<PreviewServer>): void;\n}\ntype PreviewServerHook = (this: void, server: PreviewServer) => (() => void) | void | Promise<(() => void) | void>;\n/**\n * Starts the Vite server in preview mode, to simulate a production deployment\n */\ndeclare function preview(inlineConfig?: InlineConfig): Promise<PreviewServer>;\n\ntype BindCLIShortcutsOptions<Server = ViteDevServer | PreviewServer> = {\n    /**\n     * Print a one-line shortcuts \"help\" hint to the terminal\n     */\n    print?: boolean;\n    /**\n     * Custom shortcuts to run when a key is pressed. These shortcuts take priority\n     * over the default shortcuts if they have the same keys (except the `h` key).\n     * To disable a default shortcut, define the same key but with `action: undefined`.\n     */\n    customShortcuts?: CLIShortcut<Server>[];\n};\ntype CLIShortcut<Server = ViteDevServer | PreviewServer> = {\n    key: string;\n    description: string;\n    action?(server: Server): void | Promise<void>;\n};\n\ninterface TransformResult {\n    code: string;\n    map: SourceMap | {\n        mappings: '';\n    } | null;\n    etag?: string;\n    deps?: string[];\n    dynamicDeps?: string[];\n}\ninterface TransformOptions {\n    ssr?: boolean;\n    html?: boolean;\n}\n\ndeclare class ModuleNode {\n    /**\n     * Public served url path, starts with /\n     */\n    url: string;\n    /**\n     * Resolved file system path + query\n     */\n    id: string | null;\n    file: string | null;\n    type: 'js' | 'css';\n    info?: ModuleInfo;\n    meta?: Record<string, any>;\n    importers: Set<ModuleNode>;\n    clientImportedModules: Set<ModuleNode>;\n    ssrImportedModules: Set<ModuleNode>;\n    acceptedHmrDeps: Set<ModuleNode>;\n    acceptedHmrExports: Set<string> | null;\n    importedBindings: Map<string, Set<string>> | null;\n    isSelfAccepting?: boolean;\n    transformResult: TransformResult | null;\n    ssrTransformResult: TransformResult | null;\n    ssrModule: Record<string, any> | null;\n    ssrError: Error | null;\n    lastHMRTimestamp: number;\n    lastInvalidationTimestamp: number;\n    /**\n     * @param setIsSelfAccepting - set `false` to set `isSelfAccepting` later. e.g. #7870\n     */\n    constructor(url: string, setIsSelfAccepting?: boolean);\n    get importedModules(): Set<ModuleNode>;\n}\ntype ResolvedUrl = [\n    url: string,\n    resolvedId: string,\n    meta: object | null | undefined\n];\ndeclare class ModuleGraph {\n    private resolveId;\n    urlToModuleMap: Map<string, ModuleNode>;\n    idToModuleMap: Map<string, ModuleNode>;\n    etagToModuleMap: Map<string, ModuleNode>;\n    fileToModulesMap: Map<string, Set<ModuleNode>>;\n    safeModulesPath: Set<string>;\n    constructor(resolveId: (url: string, ssr: boolean) => Promise<PartialResolvedId | null>);\n    getModuleByUrl(rawUrl: string, ssr?: boolean): Promise<ModuleNode | undefined>;\n    getModuleById(id: string): ModuleNode | undefined;\n    getModulesByFile(file: string): Set<ModuleNode> | undefined;\n    onFileChange(file: string): void;\n    onFileDelete(file: string): void;\n    invalidateModule(mod: ModuleNode, seen?: Set<ModuleNode>, timestamp?: number, isHmr?: boolean, \n    ): void;\n    invalidateAll(): void;\n    /**\n     * Update the module graph based on a module's updated imports information\n     * If there are dependencies that no longer have any importers, they are\n     * returned as a Set.\n     *\n     * @param staticImportedUrls Subset of `importedModules` where they're statically imported in code.\n     *   This is only used for soft invalidations so `undefined` is fine but may cause more runtime processing.\n     */\n    updateModuleInfo(mod: ModuleNode, importedModules: Set<string | ModuleNode>, importedBindings: Map<string, Set<string>> | null, acceptedModules: Set<string | ModuleNode>, acceptedExports: Set<string> | null, isSelfAccepting: boolean, ssr?: boolean, \n    ): Promise<Set<ModuleNode> | undefined>;\n    ensureEntryFromUrl(rawUrl: string, ssr?: boolean, setIsSelfAccepting?: boolean): Promise<ModuleNode>;\n    createFileOnlyEntry(file: string): ModuleNode;\n    resolveUrl(url: string, ssr?: boolean): Promise<ResolvedUrl>;\n    updateModuleTransformResult(mod: ModuleNode, result: TransformResult | null, ssr: boolean): void;\n    getModuleByEtag(etag: string): ModuleNode | undefined;\n}\n\n/**\n * This file is refactored into TypeScript based on\n * https://github.com/preactjs/wmr/blob/main/packages/wmr/src/lib/rollup-plugin-container.js\n */\n\ndeclare class PluginContainer {\n    config: ResolvedConfig;\n    moduleGraph?: ModuleGraph | undefined;\n    watcher?: FSWatcher | undefined;\n    plugins: readonly Plugin<any>[];\n    private _pluginContextMap;\n    private _pluginContextMapSsr;\n    private _resolvedRollupOptions?;\n    private _processesing;\n    private _seenResolves;\n    private _closed;\n    private _moduleNodeToLoadAddedImports;\n    getSortedPluginHooks: PluginHookUtils['getSortedPluginHooks'];\n    getSortedPlugins: PluginHookUtils['getSortedPlugins'];\n    watchFiles: Set<string>;\n    minimalContext: MinimalPluginContext;\n    private _updateModuleLoadAddedImports;\n    private _getAddedImports;\n    getModuleInfo(id: string): ModuleInfo | null;\n    private handleHookPromise;\n    get options(): InputOptions;\n    resolveRollupOptions(): Promise<InputOptions>;\n    private _getPluginContext;\n    private hookParallel;\n    buildStart(_options?: InputOptions): Promise<void>;\n    resolveId(rawId: string, importer?: string | undefined, options?: {\n        attributes?: Record<string, string>;\n        custom?: CustomPluginOptions;\n        skip?: Set<Plugin>;\n        ssr?: boolean;\n        isEntry?: boolean;\n    }): Promise<PartialResolvedId | null>;\n    load(id: string, options?: {\n        ssr?: boolean;\n    }): Promise<LoadResult | null>;\n    transform(code: string, id: string, options?: {\n        ssr?: boolean;\n        inMap?: SourceDescription['map'];\n    }): Promise<{\n        code: string;\n        map: SourceMap | {\n            mappings: '';\n        } | null;\n    }>;\n    watchChange(id: string, change: {\n        event: 'create' | 'update' | 'delete';\n    }): Promise<void>;\n    close(): Promise<void>;\n}\n\n// Modified and inlined to avoid extra dependency\n// Source: https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/ws/index.d.ts\n\ndeclare const WebSocketAlias: typeof WebSocket\ninterface WebSocketAlias extends WebSocket {}\n\n// WebSocket socket.\ndeclare class WebSocket extends EventEmitter {\n  /** The connection is not yet open. */\n  static readonly CONNECTING: 0\n  /** The connection is open and ready to communicate. */\n  static readonly OPEN: 1\n  /** The connection is in the process of closing. */\n  static readonly CLOSING: 2\n  /** The connection is closed. */\n  static readonly CLOSED: 3\n\n  binaryType: 'nodebuffer' | 'arraybuffer' | 'fragments'\n  readonly bufferedAmount: number\n  readonly extensions: string\n  /** Indicates whether the websocket is paused */\n  readonly isPaused: boolean\n  readonly protocol: string\n  /** The current state of the connection */\n  readonly readyState:\n    | typeof WebSocket.CONNECTING\n    | typeof WebSocket.OPEN\n    | typeof WebSocket.CLOSING\n    | typeof WebSocket.CLOSED\n  readonly url: string\n\n  /** The connection is not yet open. */\n  readonly CONNECTING: 0\n  /** The connection is open and ready to communicate. */\n  readonly OPEN: 1\n  /** The connection is in the process of closing. */\n  readonly CLOSING: 2\n  /** The connection is closed. */\n  readonly CLOSED: 3\n\n  onopen: ((event: WebSocket.Event) => void) | null\n  onerror: ((event: WebSocket.ErrorEvent) => void) | null\n  onclose: ((event: WebSocket.CloseEvent) => void) | null\n  onmessage: ((event: WebSocket.MessageEvent) => void) | null\n\n  constructor(address: null)\n  constructor(\n    address: string | URL,\n    options?: WebSocket.ClientOptions | ClientRequestArgs,\n  )\n  constructor(\n    address: string | URL,\n    protocols?: string | string[],\n    options?: WebSocket.ClientOptions | ClientRequestArgs,\n  )\n\n  close(code?: number, data?: string | Buffer): void\n  ping(data?: any, mask?: boolean, cb?: (err: Error) => void): void\n  pong(data?: any, mask?: boolean, cb?: (err: Error) => void): void\n  send(data: any, cb?: (err?: Error) => void): void\n  send(\n    data: any,\n    options: {\n      mask?: boolean | undefined\n      binary?: boolean | undefined\n      compress?: boolean | undefined\n      fin?: boolean | undefined\n    },\n    cb?: (err?: Error) => void,\n  ): void\n  terminate(): void\n\n  /**\n   * Pause the websocket causing it to stop emitting events. Some events can still be\n   * emitted after this is called, until all buffered data is consumed. This method\n   * is a noop if the ready state is `CONNECTING` or `CLOSED`.\n   */\n  pause(): void\n  /**\n   * Make a paused socket resume emitting events. This method is a noop if the ready\n   * state is `CONNECTING` or `CLOSED`.\n   */\n  resume(): void\n\n  // HTML5 WebSocket events\n  addEventListener(\n    method: 'message',\n    cb: (event: WebSocket.MessageEvent) => void,\n    options?: WebSocket.EventListenerOptions,\n  ): void\n  addEventListener(\n    method: 'close',\n    cb: (event: WebSocket.CloseEvent) => void,\n    options?: WebSocket.EventListenerOptions,\n  ): void\n  addEventListener(\n    method: 'error',\n    cb: (event: WebSocket.ErrorEvent) => void,\n    options?: WebSocket.EventListenerOptions,\n  ): void\n  addEventListener(\n    method: 'open',\n    cb: (event: WebSocket.Event) => void,\n    options?: WebSocket.EventListenerOptions,\n  ): void\n\n  removeEventListener(\n    method: 'message',\n    cb: (event: WebSocket.MessageEvent) => void,\n  ): void\n  removeEventListener(\n    method: 'close',\n    cb: (event: WebSocket.CloseEvent) => void,\n  ): void\n  removeEventListener(\n    method: 'error',\n    cb: (event: WebSocket.ErrorEvent) => void,\n  ): void\n  removeEventListener(\n    method: 'open',\n    cb: (event: WebSocket.Event) => void,\n  ): void\n\n  // Events\n  on(\n    event: 'close',\n    listener: (this: WebSocket, code: number, reason: Buffer) => void,\n  ): this\n  on(event: 'error', listener: (this: WebSocket, err: Error) => void): this\n  on(\n    event: 'upgrade',\n    listener: (this: WebSocket, request: IncomingMessage) => void,\n  ): this\n  on(\n    event: 'message',\n    listener: (\n      this: WebSocket,\n      data: WebSocket.RawData,\n      isBinary: boolean,\n    ) => void,\n  ): this\n  on(event: 'open', listener: (this: WebSocket) => void): this\n  on(\n    event: 'ping' | 'pong',\n    listener: (this: WebSocket, data: Buffer) => void,\n  ): this\n  on(\n    event: 'unexpected-response',\n    listener: (\n      this: WebSocket,\n      request: ClientRequest,\n      response: IncomingMessage,\n    ) => void,\n  ): this\n  on(\n    event: string | symbol,\n    listener: (this: WebSocket, ...args: any[]) => void,\n  ): this\n\n  once(\n    event: 'close',\n    listener: (this: WebSocket, code: number, reason: Buffer) => void,\n  ): this\n  once(event: 'error', listener: (this: WebSocket, err: Error) => void): this\n  once(\n    event: 'upgrade',\n    listener: (this: WebSocket, request: IncomingMessage) => void,\n  ): this\n  once(\n    event: 'message',\n    listener: (\n      this: WebSocket,\n      data: WebSocket.RawData,\n      isBinary: boolean,\n    ) => void,\n  ): this\n  once(event: 'open', listener: (this: WebSocket) => void): this\n  once(\n    event: 'ping' | 'pong',\n    listener: (this: WebSocket, data: Buffer) => void,\n  ): this\n  once(\n    event: 'unexpected-response',\n    listener: (\n      this: WebSocket,\n      request: ClientRequest,\n      response: IncomingMessage,\n    ) => void,\n  ): this\n  once(\n    event: string | symbol,\n    listener: (this: WebSocket, ...args: any[]) => void,\n  ): this\n\n  off(\n    event: 'close',\n    listener: (this: WebSocket, code: number, reason: Buffer) => void,\n  ): this\n  off(event: 'error', listener: (this: WebSocket, err: Error) => void): this\n  off(\n    event: 'upgrade',\n    listener: (this: WebSocket, request: IncomingMessage) => void,\n  ): this\n  off(\n    event: 'message',\n    listener: (\n      this: WebSocket,\n      data: WebSocket.RawData,\n      isBinary: boolean,\n    ) => void,\n  ): this\n  off(event: 'open', listener: (this: WebSocket) => void): this\n  off(\n    event: 'ping' | 'pong',\n    listener: (this: WebSocket, data: Buffer) => void,\n  ): this\n  off(\n    event: 'unexpected-response',\n    listener: (\n      this: WebSocket,\n      request: ClientRequest,\n      response: IncomingMessage,\n    ) => void,\n  ): this\n  off(\n    event: string | symbol,\n    listener: (this: WebSocket, ...args: any[]) => void,\n  ): this\n\n  addListener(\n    event: 'close',\n    listener: (code: number, reason: Buffer) => void,\n  ): this\n  addListener(event: 'error', listener: (err: Error) => void): this\n  addListener(\n    event: 'upgrade',\n    listener: (request: IncomingMessage) => void,\n  ): this\n  addListener(\n    event: 'message',\n    listener: (data: WebSocket.RawData, isBinary: boolean) => void,\n  ): this\n  addListener(event: 'open', listener: () => void): this\n  addListener(event: 'ping' | 'pong', listener: (data: Buffer) => void): this\n  addListener(\n    event: 'unexpected-response',\n    listener: (request: ClientRequest, response: IncomingMessage) => void,\n  ): this\n  addListener(event: string | symbol, listener: (...args: any[]) => void): this\n\n  removeListener(\n    event: 'close',\n    listener: (code: number, reason: Buffer) => void,\n  ): this\n  removeListener(event: 'error', listener: (err: Error) => void): this\n  removeListener(\n    event: 'upgrade',\n    listener: (request: IncomingMessage) => void,\n  ): this\n  removeListener(\n    event: 'message',\n    listener: (data: WebSocket.RawData, isBinary: boolean) => void,\n  ): this\n  removeListener(event: 'open', listener: () => void): this\n  removeListener(event: 'ping' | 'pong', listener: (data: Buffer) => void): this\n  removeListener(\n    event: 'unexpected-response',\n    listener: (request: ClientRequest, response: IncomingMessage) => void,\n  ): this\n  removeListener(\n    event: string | symbol,\n    listener: (...args: any[]) => void,\n  ): this\n}\n\ndeclare namespace WebSocket {\n  /**\n   * Data represents the raw message payload received over the WebSocket.\n   */\n  type RawData = Buffer | ArrayBuffer | Buffer[]\n\n  /**\n   * Data represents the message payload received over the WebSocket.\n   */\n  type Data = string | Buffer | ArrayBuffer | Buffer[]\n\n  /**\n   * CertMeta represents the accepted types for certificate & key data.\n   */\n  type CertMeta = string | string[] | Buffer | Buffer[]\n\n  /**\n   * VerifyClientCallbackSync is a synchronous callback used to inspect the\n   * incoming message. The return value (boolean) of the function determines\n   * whether or not to accept the handshake.\n   */\n  type VerifyClientCallbackSync = (info: {\n    origin: string\n    secure: boolean\n    req: IncomingMessage\n  }) => boolean\n\n  /**\n   * VerifyClientCallbackAsync is an asynchronous callback used to inspect the\n   * incoming message. The return value (boolean) of the function determines\n   * whether or not to accept the handshake.\n   */\n  type VerifyClientCallbackAsync = (\n    info: { origin: string; secure: boolean; req: IncomingMessage },\n    callback: (\n      res: boolean,\n      code?: number,\n      message?: string,\n      headers?: OutgoingHttpHeaders,\n    ) => void,\n  ) => void\n\n  interface ClientOptions extends SecureContextOptions {\n    protocol?: string | undefined\n    followRedirects?: boolean | undefined\n    generateMask?(mask: Buffer): void\n    handshakeTimeout?: number | undefined\n    maxRedirects?: number | undefined\n    perMessageDeflate?: boolean | PerMessageDeflateOptions | undefined\n    localAddress?: string | undefined\n    protocolVersion?: number | undefined\n    headers?: { [key: string]: string } | undefined\n    origin?: string | undefined\n    agent?: Agent | undefined\n    host?: string | undefined\n    family?: number | undefined\n    checkServerIdentity?(servername: string, cert: CertMeta): boolean\n    rejectUnauthorized?: boolean | undefined\n    maxPayload?: number | undefined\n    skipUTF8Validation?: boolean | undefined\n  }\n\n  interface PerMessageDeflateOptions {\n    serverNoContextTakeover?: boolean | undefined\n    clientNoContextTakeover?: boolean | undefined\n    serverMaxWindowBits?: number | undefined\n    clientMaxWindowBits?: number | undefined\n    zlibDeflateOptions?:\n      | {\n          flush?: number | undefined\n          finishFlush?: number | undefined\n          chunkSize?: number | undefined\n          windowBits?: number | undefined\n          level?: number | undefined\n          memLevel?: number | undefined\n          strategy?: number | undefined\n          dictionary?: Buffer | Buffer[] | DataView | undefined\n          info?: boolean | undefined\n        }\n      | undefined\n    zlibInflateOptions?: ZlibOptions | undefined\n    threshold?: number | undefined\n    concurrencyLimit?: number | undefined\n  }\n\n  interface Event {\n    type: string\n    target: WebSocket\n  }\n\n  interface ErrorEvent {\n    error: any\n    message: string\n    type: string\n    target: WebSocket\n  }\n\n  interface CloseEvent {\n    wasClean: boolean\n    code: number\n    reason: string\n    type: string\n    target: WebSocket\n  }\n\n  interface MessageEvent {\n    data: Data\n    type: string\n    target: WebSocket\n  }\n\n  interface EventListenerOptions {\n    once?: boolean | undefined\n  }\n\n  interface ServerOptions {\n    host?: string | undefined\n    port?: number | undefined\n    backlog?: number | undefined\n    server?: Server | HttpsServer | undefined\n    verifyClient?:\n      | VerifyClientCallbackAsync\n      | VerifyClientCallbackSync\n      | undefined\n    handleProtocols?: (\n      protocols: Set<string>,\n      request: IncomingMessage,\n    ) => string | false\n    path?: string | undefined\n    noServer?: boolean | undefined\n    clientTracking?: boolean | undefined\n    perMessageDeflate?: boolean | PerMessageDeflateOptions | undefined\n    maxPayload?: number | undefined\n    skipUTF8Validation?: boolean | undefined\n    WebSocket?: typeof WebSocket.WebSocket | undefined\n  }\n\n  interface AddressInfo {\n    address: string\n    family: string\n    port: number\n  }\n\n  // WebSocket Server\n  class Server<T extends WebSocket = WebSocket> extends EventEmitter {\n    options: ServerOptions\n    path: string\n    clients: Set<T>\n\n    constructor(options?: ServerOptions, callback?: () => void)\n\n    address(): AddressInfo | string\n    close(cb?: (err?: Error) => void): void\n    handleUpgrade(\n      request: IncomingMessage,\n      socket: Duplex,\n      upgradeHead: Buffer,\n      callback: (client: T, request: IncomingMessage) => void,\n    ): void\n    shouldHandle(request: IncomingMessage): boolean | Promise<boolean>\n\n    // Events\n    on(\n      event: 'connection',\n      cb: (this: Server<T>, socket: T, request: IncomingMessage) => void,\n    ): this\n    on(event: 'error', cb: (this: Server<T>, error: Error) => void): this\n    on(\n      event: 'headers',\n      cb: (\n        this: Server<T>,\n        headers: string[],\n        request: IncomingMessage,\n      ) => void,\n    ): this\n    on(event: 'close' | 'listening', cb: (this: Server<T>) => void): this\n    on(\n      event: string | symbol,\n      listener: (this: Server<T>, ...args: any[]) => void,\n    ): this\n\n    once(\n      event: 'connection',\n      cb: (this: Server<T>, socket: T, request: IncomingMessage) => void,\n    ): this\n    once(event: 'error', cb: (this: Server<T>, error: Error) => void): this\n    once(\n      event: 'headers',\n      cb: (\n        this: Server<T>,\n        headers: string[],\n        request: IncomingMessage,\n      ) => void,\n    ): this\n    once(event: 'close' | 'listening', cb: (this: Server<T>) => void): this\n    once(\n      event: string | symbol,\n      listener: (this: Server<T>, ...args: any[]) => void,\n    ): this\n\n    off(\n      event: 'connection',\n      cb: (this: Server<T>, socket: T, request: IncomingMessage) => void,\n    ): this\n    off(event: 'error', cb: (this: Server<T>, error: Error) => void): this\n    off(\n      event: 'headers',\n      cb: (\n        this: Server<T>,\n        headers: string[],\n        request: IncomingMessage,\n      ) => void,\n    ): this\n    off(event: 'close' | 'listening', cb: (this: Server<T>) => void): this\n    off(\n      event: string | symbol,\n      listener: (this: Server<T>, ...args: any[]) => void,\n    ): this\n\n    addListener(\n      event: 'connection',\n      cb: (client: T, request: IncomingMessage) => void,\n    ): this\n    addListener(event: 'error', cb: (err: Error) => void): this\n    addListener(\n      event: 'headers',\n      cb: (headers: string[], request: IncomingMessage) => void,\n    ): this\n    addListener(event: 'close' | 'listening', cb: () => void): this\n    addListener(\n      event: string | symbol,\n      listener: (...args: any[]) => void,\n    ): this\n\n    removeListener(event: 'connection', cb: (client: T) => void): this\n    removeListener(event: 'error', cb: (err: Error) => void): this\n    removeListener(\n      event: 'headers',\n      cb: (headers: string[], request: IncomingMessage) => void,\n    ): this\n    removeListener(event: 'close' | 'listening', cb: () => void): this\n    removeListener(\n      event: string | symbol,\n      listener: (...args: any[]) => void,\n    ): this\n  }\n\n  const WebSocketServer: typeof Server\n  interface WebSocketServer extends Server {}\n  const WebSocket: typeof WebSocketAlias\n  interface WebSocket extends WebSocketAlias {}\n\n  // WebSocket stream\n  function createWebSocketStream(\n    websocket: WebSocket,\n    options?: DuplexOptions,\n  ): Duplex\n}\n\ninterface HmrOptions {\n    protocol?: string;\n    host?: string;\n    port?: number;\n    clientPort?: number;\n    path?: string;\n    timeout?: number;\n    overlay?: boolean;\n    server?: HttpServer;\n}\ninterface HmrContext {\n    file: string;\n    timestamp: number;\n    modules: Array<ModuleNode>;\n    read: () => string | Promise<string>;\n    server: ViteDevServer;\n}\ninterface HMRBroadcasterClient {\n    /**\n     * Send event to the client\n     */\n    send(payload: HMRPayload): void;\n    /**\n     * Send custom event\n     */\n    send(event: string, payload?: CustomPayload['data']): void;\n}\ninterface HMRChannel {\n    /**\n     * Unique channel name\n     */\n    name: string;\n    /**\n     * Broadcast events to all clients\n     */\n    send(payload: HMRPayload): void;\n    /**\n     * Send custom event\n     */\n    send<T extends string>(event: T, payload?: InferCustomEventPayload<T>): void;\n    /**\n     * Handle custom event emitted by `import.meta.hot.send`\n     */\n    on<T extends string>(event: T, listener: (data: InferCustomEventPayload<T>, client: HMRBroadcasterClient, ...args: any[]) => void): void;\n    on(event: 'connection', listener: () => void): void;\n    /**\n     * Unregister event listener\n     */\n    off(event: string, listener: Function): void;\n    /**\n     * Start listening for messages\n     */\n    listen(): void;\n    /**\n     * Disconnect all clients, called when server is closed or restarted.\n     */\n    close(): void;\n}\ninterface HMRBroadcaster extends Omit<HMRChannel, 'close' | 'name'> {\n    /**\n     * All registered channels. Always has websocket channel.\n     */\n    readonly channels: HMRChannel[];\n    /**\n     * Add a new third-party channel.\n     */\n    addChannel(connection: HMRChannel): HMRBroadcaster;\n    close(): Promise<unknown[]>;\n}\ninterface ServerHMRChannel extends HMRChannel {\n    api: {\n        innerEmitter: EventEmitter;\n        outsideEmitter: EventEmitter;\n    };\n}\n\ntype WebSocketCustomListener<T> = (data: T, client: WebSocketClient) => void;\ninterface WebSocketServer extends HMRChannel {\n    /**\n     * Listen on port and host\n     */\n    listen(): void;\n    /**\n     * Get all connected clients.\n     */\n    clients: Set<WebSocketClient>;\n    /**\n     * Disconnect all clients and terminate the server.\n     */\n    close(): Promise<void>;\n    /**\n     * Handle custom event emitted by `import.meta.hot.send`\n     */\n    on: WebSocket.Server['on'] & {\n        <T extends string>(event: T, listener: WebSocketCustomListener<InferCustomEventPayload<T>>): void;\n    };\n    /**\n     * Unregister event listener.\n     */\n    off: WebSocket.Server['off'] & {\n        (event: string, listener: Function): void;\n    };\n}\ninterface WebSocketClient {\n    /**\n     * Send event to the client\n     */\n    send(payload: HMRPayload): void;\n    /**\n     * Send custom event\n     */\n    send(event: string, payload?: CustomPayload['data']): void;\n    /**\n     * The raw WebSocket instance\n     * @advanced\n     */\n    socket: WebSocket;\n}\n\ninterface ServerOptions extends CommonServerOptions {\n    /**\n     * Configure HMR-specific options (port, host, path & protocol)\n     */\n    hmr?: HmrOptions | boolean;\n    /**\n     * Do not start the websocket connection.\n     * @experimental\n     */\n    ws?: false;\n    /**\n     * Warm-up files to transform and cache the results in advance. This improves the\n     * initial page load during server starts and prevents transform waterfalls.\n     */\n    warmup?: {\n        /**\n         * The files to be transformed and used on the client-side. Supports glob patterns.\n         */\n        clientFiles?: string[];\n        /**\n         * The files to be transformed and used in SSR. Supports glob patterns.\n         */\n        ssrFiles?: string[];\n    };\n    /**\n     * chokidar watch options or null to disable FS watching\n     * https://github.com/paulmillr/chokidar#api\n     */\n    watch?: WatchOptions | null;\n    /**\n     * Create Vite dev server to be used as a middleware in an existing server\n     * @default false\n     */\n    middlewareMode?: boolean | {\n        /**\n         * Parent server instance to attach to\n         *\n         * This is needed to proxy WebSocket connections to the parent server.\n         */\n        server: HttpServer;\n    };\n    /**\n     * Options for files served via '/\\@fs/'.\n     */\n    fs?: FileSystemServeOptions;\n    /**\n     * Origin for the generated asset URLs.\n     *\n     * @example `http://127.0.0.1:8080`\n     */\n    origin?: string;\n    /**\n     * Pre-transform known direct imports\n     * @default true\n     */\n    preTransformRequests?: boolean;\n    /**\n     * Whether or not to ignore-list source files in the dev server sourcemap, used to populate\n     * the [`x_google_ignoreList` source map extension](https://developer.chrome.com/blog/devtools-better-angular-debugging/#the-x_google_ignorelist-source-map-extension).\n     *\n     * By default, it excludes all paths containing `node_modules`. You can pass `false` to\n     * disable this behavior, or, for full control, a function that takes the source path and\n     * sourcemap path and returns whether to ignore the source path.\n     */\n    sourcemapIgnoreList?: false | ((sourcePath: string, sourcemapPath: string) => boolean);\n}\ninterface ResolvedServerOptions extends Omit<ServerOptions, 'fs' | 'middlewareMode' | 'sourcemapIgnoreList'> {\n    fs: Required<FileSystemServeOptions>;\n    middlewareMode: NonNullable<ServerOptions['middlewareMode']>;\n    sourcemapIgnoreList: Exclude<ServerOptions['sourcemapIgnoreList'], false | undefined>;\n}\ninterface FileSystemServeOptions {\n    /**\n     * Strictly restrict file accessing outside of allowing paths.\n     *\n     * Set to `false` to disable the warning\n     *\n     * @default true\n     */\n    strict?: boolean;\n    /**\n     * Restrict accessing files outside the allowed directories.\n     *\n     * Accepts absolute path or a path relative to project root.\n     * Will try to search up for workspace root by default.\n     */\n    allow?: string[];\n    /**\n     * Restrict accessing files that matches the patterns.\n     *\n     * This will have higher priority than `allow`.\n     * picomatch patterns are supported.\n     *\n     * @default ['.env', '.env.*', '*.crt', '*.pem']\n     */\n    deny?: string[];\n    /**\n     * Enable caching of fs calls. It is enabled by default if no custom watch ignored patterns are provided.\n     *\n     * @experimental\n     * @default undefined\n     */\n    cachedChecks?: boolean;\n}\ntype ServerHook = (this: void, server: ViteDevServer) => (() => void) | void | Promise<(() => void) | void>;\ntype HttpServer = http.Server | Http2SecureServer;\ninterface ViteDevServer {\n    /**\n     * The resolved vite config object\n     */\n    config: ResolvedConfig;\n    /**\n     * A connect app instance.\n     * - Can be used to attach custom middlewares to the dev server.\n     * - Can also be used as the handler function of a custom http server\n     *   or as a middleware in any connect-style Node.js frameworks\n     *\n     * https://github.com/senchalabs/connect#use-middleware\n     */\n    middlewares: Connect.Server;\n    /**\n     * native Node http server instance\n     * will be null in middleware mode\n     */\n    httpServer: HttpServer | null;\n    /**\n     * chokidar watcher instance\n     * https://github.com/paulmillr/chokidar#api\n     */\n    watcher: FSWatcher;\n    /**\n     * web socket server with `send(payload)` method\n     */\n    ws: WebSocketServer;\n    /**\n     * HMR broadcaster that can be used to send custom HMR messages to the client\n     *\n     * Always sends a message to at least a WebSocket client. Any third party can\n     * add a channel to the broadcaster to process messages\n     * @deprecated will be replaced with the environment api in v6.\n     */\n    hot: HMRBroadcaster;\n    /**\n     * Rollup plugin container that can run plugin hooks on a given file\n     */\n    pluginContainer: PluginContainer;\n    /**\n     * Module graph that tracks the import relationships, url to file mapping\n     * and hmr state.\n     */\n    moduleGraph: ModuleGraph;\n    /**\n     * The resolved urls Vite prints on the CLI. null in middleware mode or\n     * before `server.listen` is called.\n     */\n    resolvedUrls: ResolvedServerUrls | null;\n    /**\n     * Programmatically resolve, load and transform a URL and get the result\n     * without going through the http request pipeline.\n     */\n    transformRequest(url: string, options?: TransformOptions): Promise<TransformResult | null>;\n    /**\n     * Same as `transformRequest` but only warm up the URLs so the next request\n     * will already be cached. The function will never throw as it handles and\n     * reports errors internally.\n     */\n    warmupRequest(url: string, options?: TransformOptions): Promise<void>;\n    /**\n     * Apply vite built-in HTML transforms and any plugin HTML transforms.\n     */\n    transformIndexHtml(url: string, html: string, originalUrl?: string): Promise<string>;\n    /**\n     * Transform module code into SSR format.\n     */\n    ssrTransform(code: string, inMap: SourceMap | {\n        mappings: '';\n    } | null, url: string, originalCode?: string): Promise<TransformResult | null>;\n    /**\n     * Load a given URL as an instantiated module for SSR.\n     */\n    ssrLoadModule(url: string, opts?: {\n        fixStacktrace?: boolean;\n    }): Promise<Record<string, any>>;\n    /**\n     * Fetch information about the module for Vite SSR runtime.\n     * @experimental\n     */\n    ssrFetchModule(id: string, importer?: string): Promise<FetchResult>;\n    /**\n     * Returns a fixed version of the given stack\n     */\n    ssrRewriteStacktrace(stack: string): string;\n    /**\n     * Mutates the given SSR error by rewriting the stacktrace\n     */\n    ssrFixStacktrace(e: Error): void;\n    /**\n     * Triggers HMR for a module in the module graph. You can use the `server.moduleGraph`\n     * API to retrieve the module to be reloaded. If `hmr` is false, this is a no-op.\n     */\n    reloadModule(module: ModuleNode): Promise<void>;\n    /**\n     * Start the server.\n     */\n    listen(port?: number, isRestart?: boolean): Promise<ViteDevServer>;\n    /**\n     * Stop the server.\n     */\n    close(): Promise<void>;\n    /**\n     * Print server urls\n     */\n    printUrls(): void;\n    /**\n     * Bind CLI shortcuts\n     */\n    bindCLIShortcuts(options?: BindCLIShortcutsOptions<ViteDevServer>): void;\n    /**\n     * Restart the server.\n     *\n     * @param forceOptimize - force the optimizer to re-bundle, same as --force cli flag\n     */\n    restart(forceOptimize?: boolean): Promise<void>;\n    /**\n     * Open browser\n     */\n    openBrowser(): void;\n    /**\n     * Calling `await server.waitForRequestsIdle(id)` will wait until all static imports\n     * are processed. If called from a load or transform plugin hook, the id needs to be\n     * passed as a parameter to avoid deadlocks. Calling this function after the first\n     * static imports section of the module graph has been processed will resolve immediately.\n     * @experimental\n     */\n    waitForRequestsIdle: (ignoredId?: string) => Promise<void>;\n}\ninterface ResolvedServerUrls {\n    local: string[];\n    network: string[];\n}\ndeclare function createServer(inlineConfig?: InlineConfig): Promise<ViteDevServer>;\n\n/** Cache for package.json resolution and package.json contents */\ntype PackageCache = Map<string, PackageData>;\ninterface PackageData {\n    dir: string;\n    hasSideEffects: (id: string) => boolean | 'no-treeshake' | null;\n    webResolvedImports: Record<string, string | undefined>;\n    nodeResolvedImports: Record<string, string | undefined>;\n    setResolvedCache: (key: string, entry: string, targetWeb: boolean) => void;\n    getResolvedCache: (key: string, targetWeb: boolean) => string | undefined;\n    data: {\n        [field: string]: any;\n        name: string;\n        type: string;\n        version: string;\n        main: string;\n        module: string;\n        browser: string | Record<string, string | false>;\n        exports: string | Record<string, any> | string[];\n        imports: Record<string, any>;\n        dependencies: Record<string, string>;\n    };\n}\n\ninterface RollupCommonJSOptions {\n  /**\n   * A minimatch pattern, or array of patterns, which specifies the files in\n   * the build the plugin should operate on. By default, all files with\n   * extension `\".cjs\"` or those in `extensions` are included, but you can\n   * narrow this list by only including specific files. These files will be\n   * analyzed and transpiled if either the analysis does not find ES module\n   * specific statements or `transformMixedEsModules` is `true`.\n   * @default undefined\n   */\n  include?: string | RegExp | readonly (string | RegExp)[]\n  /**\n   * A minimatch pattern, or array of patterns, which specifies the files in\n   * the build the plugin should _ignore_. By default, all files with\n   * extensions other than those in `extensions` or `\".cjs\"` are ignored, but you\n   * can exclude additional files. See also the `include` option.\n   * @default undefined\n   */\n  exclude?: string | RegExp | readonly (string | RegExp)[]\n  /**\n   * For extensionless imports, search for extensions other than .js in the\n   * order specified. Note that you need to make sure that non-JavaScript files\n   * are transpiled by another plugin first.\n   * @default [ '.js' ]\n   */\n  extensions?: ReadonlyArray<string>\n  /**\n   * If true then uses of `global` won't be dealt with by this plugin\n   * @default false\n   */\n  ignoreGlobal?: boolean\n  /**\n   * If false, skips source map generation for CommonJS modules. This will\n   * improve performance.\n   * @default true\n   */\n  sourceMap?: boolean\n  /**\n   * Some `require` calls cannot be resolved statically to be translated to\n   * imports.\n   * When this option is set to `false`, the generated code will either\n   * directly throw an error when such a call is encountered or, when\n   * `dynamicRequireTargets` is used, when such a call cannot be resolved with a\n   * configured dynamic require target.\n   * Setting this option to `true` will instead leave the `require` call in the\n   * code or use it as a fallback for `dynamicRequireTargets`.\n   * @default false\n   */\n  ignoreDynamicRequires?: boolean\n  /**\n   * Instructs the plugin whether to enable mixed module transformations. This\n   * is useful in scenarios with modules that contain a mix of ES `import`\n   * statements and CommonJS `require` expressions. Set to `true` if `require`\n   * calls should be transformed to imports in mixed modules, or `false` if the\n   * `require` expressions should survive the transformation. The latter can be\n   * important if the code contains environment detection, or you are coding\n   * for an environment with special treatment for `require` calls such as\n   * ElectronJS. See also the `ignore` option.\n   * @default false\n   */\n  transformMixedEsModules?: boolean\n  /**\n   * By default, this plugin will try to hoist `require` statements as imports\n   * to the top of each file. While this works well for many code bases and\n   * allows for very efficient ESM output, it does not perfectly capture\n   * CommonJS semantics as the order of side effects like log statements may\n   * change. But it is especially problematic when there are circular `require`\n   * calls between CommonJS modules as those often rely on the lazy execution of\n   * nested `require` calls.\n   *\n   * Setting this option to `true` will wrap all CommonJS files in functions\n   * which are executed when they are required for the first time, preserving\n   * NodeJS semantics. Note that this can have an impact on the size and\n   * performance of the generated code.\n   *\n   * The default value of `\"auto\"` will only wrap CommonJS files when they are\n   * part of a CommonJS dependency cycle, e.g. an index file that is required by\n   * many of its dependencies. All other CommonJS files are hoisted. This is the\n   * recommended setting for most code bases.\n   *\n   * `false` will entirely prevent wrapping and hoist all files. This may still\n   * work depending on the nature of cyclic dependencies but will often cause\n   * problems.\n   *\n   * You can also provide a minimatch pattern, or array of patterns, to only\n   * specify a subset of files which should be wrapped in functions for proper\n   * `require` semantics.\n   *\n   * `\"debug\"` works like `\"auto\"` but after bundling, it will display a warning\n   * containing a list of ids that have been wrapped which can be used as\n   * minimatch pattern for fine-tuning.\n   * @default \"auto\"\n   */\n  strictRequires?: boolean | string | RegExp | readonly (string | RegExp)[]\n  /**\n   * Sometimes you have to leave require statements unconverted. Pass an array\n   * containing the IDs or a `id => boolean` function.\n   * @default []\n   */\n  ignore?: ReadonlyArray<string> | ((id: string) => boolean)\n  /**\n   * In most cases, where `require` calls are inside a `try-catch` clause,\n   * they should be left unconverted as it requires an optional dependency\n   * that may or may not be installed beside the rolled up package.\n   * Due to the conversion of `require` to a static `import` - the call is\n   * hoisted to the top of the file, outside the `try-catch` clause.\n   *\n   * - `true`: Default. All `require` calls inside a `try` will be left unconverted.\n   * - `false`: All `require` calls inside a `try` will be converted as if the\n   *   `try-catch` clause is not there.\n   * - `remove`: Remove all `require` calls from inside any `try` block.\n   * - `string[]`: Pass an array containing the IDs to left unconverted.\n   * - `((id: string) => boolean|'remove')`: Pass a function that controls\n   *   individual IDs.\n   *\n   * @default true\n   */\n  ignoreTryCatch?:\n    | boolean\n    | 'remove'\n    | ReadonlyArray<string>\n    | ((id: string) => boolean | 'remove')\n  /**\n   * Controls how to render imports from external dependencies. By default,\n   * this plugin assumes that all external dependencies are CommonJS. This\n   * means they are rendered as default imports to be compatible with e.g.\n   * NodeJS where ES modules can only import a default export from a CommonJS\n   * dependency.\n   *\n   * If you set `esmExternals` to `true`, this plugin assumes that all\n   * external dependencies are ES modules and respect the\n   * `requireReturnsDefault` option. If that option is not set, they will be\n   * rendered as namespace imports.\n   *\n   * You can also supply an array of ids to be treated as ES modules, or a\n   * function that will be passed each external id to determine whether it is\n   * an ES module.\n   * @default false\n   */\n  esmExternals?: boolean | ReadonlyArray<string> | ((id: string) => boolean)\n  /**\n   * Controls what is returned when requiring an ES module from a CommonJS file.\n   * When using the `esmExternals` option, this will also apply to external\n   * modules. By default, this plugin will render those imports as namespace\n   * imports i.e.\n   *\n   * ```js\n   * // input\n   * const foo = require('foo');\n   *\n   * // output\n   * import * as foo from 'foo';\n   * ```\n   *\n   * However, there are some situations where this may not be desired.\n   * For these situations, you can change Rollup's behaviour either globally or\n   * per module. To change it globally, set the `requireReturnsDefault` option\n   * to one of the following values:\n   *\n   * - `false`: This is the default, requiring an ES module returns its\n   *   namespace. This is the only option that will also add a marker\n   *   `__esModule: true` to the namespace to support interop patterns in\n   *   CommonJS modules that are transpiled ES modules.\n   * - `\"namespace\"`: Like `false`, requiring an ES module returns its\n   *   namespace, but the plugin does not add the `__esModule` marker and thus\n   *   creates more efficient code. For external dependencies when using\n   *   `esmExternals: true`, no additional interop code is generated.\n   * - `\"auto\"`: This is complementary to how `output.exports: \"auto\"` works in\n   *   Rollup: If a module has a default export and no named exports, requiring\n   *   that module returns the default export. In all other cases, the namespace\n   *   is returned. For external dependencies when using `esmExternals: true`, a\n   *   corresponding interop helper is added.\n   * - `\"preferred\"`: If a module has a default export, requiring that module\n   *   always returns the default export, no matter whether additional named\n   *   exports exist. This is similar to how previous versions of this plugin\n   *   worked. Again for external dependencies when using `esmExternals: true`,\n   *   an interop helper is added.\n   * - `true`: This will always try to return the default export on require\n   *   without checking if it actually exists. This can throw at build time if\n   *   there is no default export. This is how external dependencies are handled\n   *   when `esmExternals` is not used. The advantage over the other options is\n   *   that, like `false`, this does not add an interop helper for external\n   *   dependencies, keeping the code lean.\n   *\n   * To change this for individual modules, you can supply a function for\n   * `requireReturnsDefault` instead. This function will then be called once for\n   * each required ES module or external dependency with the corresponding id\n   * and allows you to return different values for different modules.\n   * @default false\n   */\n  requireReturnsDefault?:\n    | boolean\n    | 'auto'\n    | 'preferred'\n    | 'namespace'\n    | ((id: string) => boolean | 'auto' | 'preferred' | 'namespace')\n\n  /**\n   * @default \"auto\"\n   */\n  defaultIsModuleExports?: boolean | 'auto' | ((id: string) => boolean | 'auto')\n  /**\n   * Some modules contain dynamic `require` calls, or require modules that\n   * contain circular dependencies, which are not handled well by static\n   * imports. Including those modules as `dynamicRequireTargets` will simulate a\n   * CommonJS (NodeJS-like) environment for them with support for dynamic\n   * dependencies. It also enables `strictRequires` for those modules.\n   *\n   * Note: In extreme cases, this feature may result in some paths being\n   * rendered as absolute in the final bundle. The plugin tries to avoid\n   * exposing paths from the local machine, but if you are `dynamicRequirePaths`\n   * with paths that are far away from your project's folder, that may require\n   * replacing strings like `\"/Users/John/Desktop/foo-project/\"` -\\> `\"/\"`.\n   */\n  dynamicRequireTargets?: string | ReadonlyArray<string>\n  /**\n   * To avoid long paths when using the `dynamicRequireTargets` option, you can use this option to specify a directory\n   * that is a common parent for all files that use dynamic require statements. Using a directory higher up such as `/`\n   * may lead to unnecessarily long paths in the generated code and may expose directory names on your machine like your\n   * home directory name. By default, it uses the current working directory.\n   */\n  dynamicRequireRoot?: string\n}\n\ninterface RollupDynamicImportVarsOptions {\n  /**\n   * Files to include in this plugin (default all).\n   * @default []\n   */\n  include?: string | RegExp | (string | RegExp)[]\n  /**\n   * Files to exclude in this plugin (default none).\n   * @default []\n   */\n  exclude?: string | RegExp | (string | RegExp)[]\n  /**\n   * By default, the plugin quits the build process when it encounters an error. If you set this option to true, it will throw a warning instead and leave the code untouched.\n   * @default false\n   */\n  warnOnError?: boolean\n}\n\n// Modified and inlined to avoid extra dependency\n// Source: https://github.com/terser/terser/blob/master/tools/terser.d.ts\n// BSD Licensed https://github.com/terser/terser/blob/master/LICENSE\n\ndeclare namespace Terser {\n  export type ECMA = 5 | 2015 | 2016 | 2017 | 2018 | 2019 | 2020\n\n  export type ConsoleProperty = keyof typeof console\n  type DropConsoleOption = boolean | ConsoleProperty[]\n\n  export interface ParseOptions {\n    bare_returns?: boolean\n    /** @deprecated legacy option. Currently, all supported EcmaScript is valid to parse. */\n    ecma?: ECMA\n    html5_comments?: boolean\n    shebang?: boolean\n  }\n\n  export interface CompressOptions {\n    arguments?: boolean\n    arrows?: boolean\n    booleans_as_integers?: boolean\n    booleans?: boolean\n    collapse_vars?: boolean\n    comparisons?: boolean\n    computed_props?: boolean\n    conditionals?: boolean\n    dead_code?: boolean\n    defaults?: boolean\n    directives?: boolean\n    drop_console?: DropConsoleOption\n    drop_debugger?: boolean\n    ecma?: ECMA\n    evaluate?: boolean\n    expression?: boolean\n    global_defs?: object\n    hoist_funs?: boolean\n    hoist_props?: boolean\n    hoist_vars?: boolean\n    ie8?: boolean\n    if_return?: boolean\n    inline?: boolean | InlineFunctions\n    join_vars?: boolean\n    keep_classnames?: boolean | RegExp\n    keep_fargs?: boolean\n    keep_fnames?: boolean | RegExp\n    keep_infinity?: boolean\n    loops?: boolean\n    module?: boolean\n    negate_iife?: boolean\n    passes?: number\n    properties?: boolean\n    pure_funcs?: string[]\n    pure_new?: boolean\n    pure_getters?: boolean | 'strict'\n    reduce_funcs?: boolean\n    reduce_vars?: boolean\n    sequences?: boolean | number\n    side_effects?: boolean\n    switches?: boolean\n    toplevel?: boolean\n    top_retain?: null | string | string[] | RegExp\n    typeofs?: boolean\n    unsafe_arrows?: boolean\n    unsafe?: boolean\n    unsafe_comps?: boolean\n    unsafe_Function?: boolean\n    unsafe_math?: boolean\n    unsafe_symbols?: boolean\n    unsafe_methods?: boolean\n    unsafe_proto?: boolean\n    unsafe_regexp?: boolean\n    unsafe_undefined?: boolean\n    unused?: boolean\n  }\n\n  export enum InlineFunctions {\n    Disabled = 0,\n    SimpleFunctions = 1,\n    WithArguments = 2,\n    WithArgumentsAndVariables = 3,\n  }\n\n  export interface MangleOptions {\n    eval?: boolean\n    keep_classnames?: boolean | RegExp\n    keep_fnames?: boolean | RegExp\n    module?: boolean\n    nth_identifier?: SimpleIdentifierMangler | WeightedIdentifierMangler\n    properties?: boolean | ManglePropertiesOptions\n    reserved?: string[]\n    safari10?: boolean\n    toplevel?: boolean\n  }\n\n  /**\n   * An identifier mangler for which the output is invariant with respect to the source code.\n   */\n  export interface SimpleIdentifierMangler {\n    /**\n     * Obtains the nth most favored (usually shortest) identifier to rename a variable to.\n     * The mangler will increment n and retry until the return value is not in use in scope, and is not a reserved word.\n     * This function is expected to be stable; Evaluating get(n) === get(n) should always return true.\n     * @param n The ordinal of the identifier.\n     */\n    get(n: number): string\n  }\n\n  /**\n   * An identifier mangler that leverages character frequency analysis to determine identifier precedence.\n   */\n  export interface WeightedIdentifierMangler extends SimpleIdentifierMangler {\n    /**\n     * Modifies the internal weighting of the input characters by the specified delta.\n     * Will be invoked on the entire printed AST, and then deduct mangleable identifiers.\n     * @param chars The characters to modify the weighting of.\n     * @param delta The numeric weight to add to the characters.\n     */\n    consider(chars: string, delta: number): number\n    /**\n     * Resets character weights.\n     */\n    reset(): void\n    /**\n     * Sorts identifiers by character frequency, in preparation for calls to get(n).\n     */\n    sort(): void\n  }\n\n  export interface ManglePropertiesOptions {\n    builtins?: boolean\n    debug?: boolean\n    keep_quoted?: boolean | 'strict'\n    nth_identifier?: SimpleIdentifierMangler | WeightedIdentifierMangler\n    regex?: RegExp | string\n    reserved?: string[]\n  }\n\n  export interface FormatOptions {\n    ascii_only?: boolean\n    /** @deprecated Not implemented anymore */\n    beautify?: boolean\n    braces?: boolean\n    comments?:\n      | boolean\n      | 'all'\n      | 'some'\n      | RegExp\n      | ((\n          node: any,\n          comment: {\n            value: string\n            type: 'comment1' | 'comment2' | 'comment3' | 'comment4'\n            pos: number\n            line: number\n            col: number\n          },\n        ) => boolean)\n    ecma?: ECMA\n    ie8?: boolean\n    keep_numbers?: boolean\n    indent_level?: number\n    indent_start?: number\n    inline_script?: boolean\n    keep_quoted_props?: boolean\n    max_line_len?: number | false\n    preamble?: string\n    preserve_annotations?: boolean\n    quote_keys?: boolean\n    quote_style?: OutputQuoteStyle\n    safari10?: boolean\n    semicolons?: boolean\n    shebang?: boolean\n    shorthand?: boolean\n    source_map?: SourceMapOptions\n    webkit?: boolean\n    width?: number\n    wrap_iife?: boolean\n    wrap_func_args?: boolean\n  }\n\n  export enum OutputQuoteStyle {\n    PreferDouble = 0,\n    AlwaysSingle = 1,\n    AlwaysDouble = 2,\n    AlwaysOriginal = 3,\n  }\n\n  export interface MinifyOptions {\n    compress?: boolean | CompressOptions\n    ecma?: ECMA\n    enclose?: boolean | string\n    ie8?: boolean\n    keep_classnames?: boolean | RegExp\n    keep_fnames?: boolean | RegExp\n    mangle?: boolean | MangleOptions\n    module?: boolean\n    nameCache?: object\n    format?: FormatOptions\n    /** @deprecated */\n    output?: FormatOptions\n    parse?: ParseOptions\n    safari10?: boolean\n    sourceMap?: boolean | SourceMapOptions\n    toplevel?: boolean\n  }\n\n  export interface MinifyOutput {\n    code?: string\n    map?: object | string\n    decoded_map?: object | null\n  }\n\n  export interface SourceMapOptions {\n    /** Source map object, 'inline' or source map file content */\n    content?: object | string\n    includeSources?: boolean\n    filename?: string\n    root?: string\n    asObject?: boolean\n    url?: string | 'inline'\n  }\n}\n\ninterface TerserOptions extends Terser.MinifyOptions {\n    /**\n     * Vite-specific option to specify the max number of workers to spawn\n     * when minifying files with terser.\n     *\n     * @default number of CPUs minus 1\n     */\n    maxWorkers?: number;\n}\n\ninterface BuildOptions {\n    /**\n     * Compatibility transform target. The transform is performed with esbuild\n     * and the lowest supported target is es2015/es6. Note this only handles\n     * syntax transformation and does not cover polyfills (except for dynamic\n     * import)\n     *\n     * Default: 'modules' - Similar to `@babel/preset-env`'s targets.esmodules,\n     * transpile targeting browsers that natively support dynamic es module imports.\n     * https://caniuse.com/es6-module-dynamic-import\n     *\n     * Another special value is 'esnext' - which only performs minimal transpiling\n     * (for minification compat) and assumes native dynamic imports support.\n     *\n     * For custom targets, see https://esbuild.github.io/api/#target and\n     * https://esbuild.github.io/content-types/#javascript for more details.\n     * @default 'modules'\n     */\n    target?: 'modules' | esbuild_TransformOptions['target'] | false;\n    /**\n     * whether to inject module preload polyfill.\n     * Note: does not apply to library mode.\n     * @default true\n     * @deprecated use `modulePreload.polyfill` instead\n     */\n    polyfillModulePreload?: boolean;\n    /**\n     * Configure module preload\n     * Note: does not apply to library mode.\n     * @default true\n     */\n    modulePreload?: boolean | ModulePreloadOptions;\n    /**\n     * Directory relative from `root` where build output will be placed. If the\n     * directory exists, it will be removed before the build.\n     * @default 'dist'\n     */\n    outDir?: string;\n    /**\n     * Directory relative from `outDir` where the built js/css/image assets will\n     * be placed.\n     * @default 'assets'\n     */\n    assetsDir?: string;\n    /**\n     * Static asset files smaller than this number (in bytes) will be inlined as\n     * base64 strings. Default limit is `4096` (4 KiB). Set to `0` to disable.\n     * @default 4096\n     */\n    assetsInlineLimit?: number | ((filePath: string, content: Buffer) => boolean | undefined);\n    /**\n     * Whether to code-split CSS. When enabled, CSS in async chunks will be\n     * inlined as strings in the chunk and inserted via dynamically created\n     * style tags when the chunk is loaded.\n     * @default true\n     */\n    cssCodeSplit?: boolean;\n    /**\n     * An optional separate target for CSS minification.\n     * As esbuild only supports configuring targets to mainstream\n     * browsers, users may need this option when they are targeting\n     * a niche browser that comes with most modern JavaScript features\n     * but has poor CSS support, e.g. Android WeChat WebView, which\n     * doesn't support the #RGBA syntax.\n     * @default target\n     */\n    cssTarget?: esbuild_TransformOptions['target'] | false;\n    /**\n     * Override CSS minification specifically instead of defaulting to `build.minify`,\n     * so you can configure minification for JS and CSS separately.\n     * @default 'esbuild'\n     */\n    cssMinify?: boolean | 'esbuild' | 'lightningcss';\n    /**\n     * If `true`, a separate sourcemap file will be created. If 'inline', the\n     * sourcemap will be appended to the resulting output file as data URI.\n     * 'hidden' works like `true` except that the corresponding sourcemap\n     * comments in the bundled files are suppressed.\n     * @default false\n     */\n    sourcemap?: boolean | 'inline' | 'hidden';\n    /**\n     * Set to `false` to disable minification, or specify the minifier to use.\n     * Available options are 'terser' or 'esbuild'.\n     * @default 'esbuild'\n     */\n    minify?: boolean | 'terser' | 'esbuild';\n    /**\n     * Options for terser\n     * https://terser.org/docs/api-reference#minify-options\n     *\n     * In addition, you can also pass a `maxWorkers: number` option to specify the\n     * max number of workers to spawn. Defaults to the number of CPUs minus 1.\n     */\n    terserOptions?: TerserOptions;\n    /**\n     * Will be merged with internal rollup options.\n     * https://rollupjs.org/configuration-options/\n     */\n    rollupOptions?: RollupOptions;\n    /**\n     * Options to pass on to `@rollup/plugin-commonjs`\n     */\n    commonjsOptions?: RollupCommonJSOptions;\n    /**\n     * Options to pass on to `@rollup/plugin-dynamic-import-vars`\n     */\n    dynamicImportVarsOptions?: RollupDynamicImportVarsOptions;\n    /**\n     * Whether to write bundle to disk\n     * @default true\n     */\n    write?: boolean;\n    /**\n     * Empty outDir on write.\n     * @default true when outDir is a sub directory of project root\n     */\n    emptyOutDir?: boolean | null;\n    /**\n     * Copy the public directory to outDir on write.\n     * @default true\n     */\n    copyPublicDir?: boolean;\n    /**\n     * Whether to emit a .vite/manifest.json under assets dir to map hash-less filenames\n     * to their hashed versions. Useful when you want to generate your own HTML\n     * instead of using the one generated by Vite.\n     *\n     * Example:\n     *\n     * ```json\n     * {\n     *   \"main.js\": {\n     *     \"file\": \"main.68fe3fad.js\",\n     *     \"css\": \"main.e6b63442.css\",\n     *     \"imports\": [...],\n     *     \"dynamicImports\": [...]\n     *   }\n     * }\n     * ```\n     * @default false\n     */\n    manifest?: boolean | string;\n    /**\n     * Build in library mode. The value should be the global name of the lib in\n     * UMD mode. This will produce esm + cjs + umd bundle formats with default\n     * configurations that are suitable for distributing libraries.\n     * @default false\n     */\n    lib?: LibraryOptions | false;\n    /**\n     * Produce SSR oriented build. Note this requires specifying SSR entry via\n     * `rollupOptions.input`.\n     * @default false\n     */\n    ssr?: boolean | string;\n    /**\n     * Generate SSR manifest for determining style links and asset preload\n     * directives in production.\n     * @default false\n     */\n    ssrManifest?: boolean | string;\n    /**\n     * Emit assets during SSR.\n     * @default false\n     */\n    ssrEmitAssets?: boolean;\n    /**\n     * Set to false to disable reporting compressed chunk sizes.\n     * Can slightly improve build speed.\n     * @default true\n     */\n    reportCompressedSize?: boolean;\n    /**\n     * Adjust chunk size warning limit (in kB).\n     * @default 500\n     */\n    chunkSizeWarningLimit?: number;\n    /**\n     * Rollup watch options\n     * https://rollupjs.org/configuration-options/#watch\n     * @default null\n     */\n    watch?: WatcherOptions | null;\n}\ninterface LibraryOptions {\n    /**\n     * Path of library entry\n     */\n    entry: InputOption;\n    /**\n     * The name of the exposed global variable. Required when the `formats` option includes\n     * `umd` or `iife`\n     */\n    name?: string;\n    /**\n     * Output bundle formats\n     * @default ['es', 'umd']\n     */\n    formats?: LibraryFormats[];\n    /**\n     * The name of the package file output. The default file name is the name option\n     * of the project package.json. It can also be defined as a function taking the\n     * format as an argument.\n     */\n    fileName?: string | ((format: ModuleFormat, entryName: string) => string);\n}\ntype LibraryFormats = 'es' | 'cjs' | 'umd' | 'iife' | 'system';\ninterface ModulePreloadOptions {\n    /**\n     * Whether to inject a module preload polyfill.\n     * Note: does not apply to library mode.\n     * @default true\n     */\n    polyfill?: boolean;\n    /**\n     * Resolve the list of dependencies to preload for a given dynamic import\n     * @experimental\n     */\n    resolveDependencies?: ResolveModulePreloadDependenciesFn;\n}\ninterface ResolvedModulePreloadOptions {\n    polyfill: boolean;\n    resolveDependencies?: ResolveModulePreloadDependenciesFn;\n}\ntype ResolveModulePreloadDependenciesFn = (filename: string, deps: string[], context: {\n    hostId: string;\n    hostType: 'html' | 'js';\n}) => string[];\ninterface ResolvedBuildOptions extends Required<Omit<BuildOptions, 'polyfillModulePreload'>> {\n    modulePreload: false | ResolvedModulePreloadOptions;\n}\n/**\n * Bundles the app for production.\n * Returns a Promise containing the build result.\n */\ndeclare function build(inlineConfig?: InlineConfig): Promise<RollupOutput | RollupOutput[] | RollupWatcher>;\ntype RenderBuiltAssetUrl = (filename: string, type: {\n    type: 'asset' | 'public';\n    hostId: string;\n    hostType: 'js' | 'css' | 'html';\n    ssr: boolean;\n}) => string | {\n    relative?: boolean;\n    runtime?: string;\n} | undefined;\n\ninterface ESBuildOptions extends esbuild_TransformOptions {\n    include?: string | RegExp | string[] | RegExp[];\n    exclude?: string | RegExp | string[] | RegExp[];\n    jsxInject?: string;\n    /**\n     * This option is not respected. Use `build.minify` instead.\n     */\n    minify?: never;\n}\ntype ESBuildTransformResult = Omit<esbuild_TransformResult, 'map'> & {\n    map: SourceMap;\n};\ndeclare function transformWithEsbuild(code: string, filename: string, options?: esbuild_TransformOptions, inMap?: object): Promise<ESBuildTransformResult>;\n\ntype ExportsData = {\n    hasModuleSyntax: boolean;\n    exports: readonly string[];\n    jsxLoader?: boolean;\n};\ninterface DepsOptimizer {\n    metadata: DepOptimizationMetadata;\n    scanProcessing?: Promise<void>;\n    registerMissingImport: (id: string, resolved: string) => OptimizedDepInfo;\n    run: () => void;\n    isOptimizedDepFile: (id: string) => boolean;\n    isOptimizedDepUrl: (url: string) => boolean;\n    getOptimizedDepId: (depInfo: OptimizedDepInfo) => string;\n    close: () => Promise<void>;\n    options: DepOptimizationOptions;\n}\ninterface DepOptimizationConfig {\n    /**\n     * Force optimize listed dependencies (must be resolvable import paths,\n     * cannot be globs).\n     */\n    include?: string[];\n    /**\n     * Do not optimize these dependencies (must be resolvable import paths,\n     * cannot be globs).\n     */\n    exclude?: string[];\n    /**\n     * Forces ESM interop when importing these dependencies. Some legacy\n     * packages advertise themselves as ESM but use `require` internally\n     * @experimental\n     */\n    needsInterop?: string[];\n    /**\n     * Options to pass to esbuild during the dep scanning and optimization\n     *\n     * Certain options are omitted since changing them would not be compatible\n     * with Vite's dep optimization.\n     *\n     * - `external` is also omitted, use Vite's `optimizeDeps.exclude` option\n     * - `plugins` are merged with Vite's dep plugin\n     *\n     * https://esbuild.github.io/api\n     */\n    esbuildOptions?: Omit<esbuild_BuildOptions, 'bundle' | 'entryPoints' | 'external' | 'write' | 'watch' | 'outdir' | 'outfile' | 'outbase' | 'outExtension' | 'metafile'>;\n    /**\n     * List of file extensions that can be optimized. A corresponding esbuild\n     * plugin must exist to handle the specific extension.\n     *\n     * By default, Vite can optimize `.mjs`, `.js`, `.ts`, and `.mts` files. This option\n     * allows specifying additional extensions.\n     *\n     * @experimental\n     */\n    extensions?: string[];\n    /**\n     * Deps optimization during build was removed in Vite 5.1. This option is\n     * now redundant and will be removed in a future version. Switch to using\n     * `optimizeDeps.noDiscovery` and an empty or undefined `optimizeDeps.include`.\n     * true or 'dev' disables the optimizer, false or 'build' leaves it enabled.\n     * @default 'build'\n     * @deprecated\n     * @experimental\n     */\n    disabled?: boolean | 'build' | 'dev';\n    /**\n     * Automatic dependency discovery. When `noDiscovery` is true, only dependencies\n     * listed in `include` will be optimized. The scanner isn't run for cold start\n     * in this case. CJS-only dependencies must be present in `include` during dev.\n     * @default false\n     * @experimental\n     */\n    noDiscovery?: boolean;\n    /**\n     * When enabled, it will hold the first optimized deps results until all static\n     * imports are crawled on cold start. This avoids the need for full-page reloads\n     * when new dependencies are discovered and they trigger the generation of new\n     * common chunks. If all dependencies are found by the scanner plus the explicitly\n     * defined ones in `include`, it is better to disable this option to let the\n     * browser process more requests in parallel.\n     * @default true\n     * @experimental\n     */\n    holdUntilCrawlEnd?: boolean;\n}\ntype DepOptimizationOptions = DepOptimizationConfig & {\n    /**\n     * By default, Vite will crawl your `index.html` to detect dependencies that\n     * need to be pre-bundled. If `build.rollupOptions.input` is specified, Vite\n     * will crawl those entry points instead.\n     *\n     * If neither of these fit your needs, you can specify custom entries using\n     * this option - the value should be a fast-glob pattern or array of patterns\n     * (https://github.com/mrmlnc/fast-glob#basic-syntax) that are relative from\n     * vite project root. This will overwrite default entries inference.\n     */\n    entries?: string | string[];\n    /**\n     * Force dep pre-optimization regardless of whether deps have changed.\n     * @experimental\n     */\n    force?: boolean;\n};\ninterface OptimizedDepInfo {\n    id: string;\n    file: string;\n    src?: string;\n    needsInterop?: boolean;\n    browserHash?: string;\n    fileHash?: string;\n    /**\n     * During optimization, ids can still be resolved to their final location\n     * but the bundles may not yet be saved to disk\n     */\n    processing?: Promise<void>;\n    /**\n     * ExportData cache, discovered deps will parse the src entry to get exports\n     * data used both to define if interop is needed and when pre-bundling\n     */\n    exportsData?: Promise<ExportsData>;\n}\ninterface DepOptimizationMetadata {\n    /**\n     * The main hash is determined by user config and dependency lockfiles.\n     * This is checked on server startup to avoid unnecessary re-bundles.\n     */\n    hash: string;\n    /**\n     * This hash is determined by dependency lockfiles.\n     * This is checked on server startup to avoid unnecessary re-bundles.\n     */\n    lockfileHash: string;\n    /**\n     * This hash is determined by user config.\n     * This is checked on server startup to avoid unnecessary re-bundles.\n     */\n    configHash: string;\n    /**\n     * The browser hash is determined by the main hash plus additional dependencies\n     * discovered at runtime. This is used to invalidate browser requests to\n     * optimized deps.\n     */\n    browserHash: string;\n    /**\n     * Metadata for each already optimized dependency\n     */\n    optimized: Record<string, OptimizedDepInfo>;\n    /**\n     * Metadata for non-entry optimized chunks and dynamic imports\n     */\n    chunks: Record<string, OptimizedDepInfo>;\n    /**\n     * Metadata for each newly discovered dependency after processing\n     */\n    discovered: Record<string, OptimizedDepInfo>;\n    /**\n     * OptimizedDepInfo list\n     */\n    depInfoList: OptimizedDepInfo[];\n}\n/**\n * Scan and optimize dependencies within a project.\n * Used by Vite CLI when running `vite optimize`.\n */\ndeclare function optimizeDeps(config: ResolvedConfig, force?: boolean | undefined, asCommand?: boolean): Promise<DepOptimizationMetadata>;\n\ntype SSRTarget = 'node' | 'webworker';\ntype SsrDepOptimizationOptions = DepOptimizationConfig;\ninterface SSROptions {\n    noExternal?: string | RegExp | (string | RegExp)[] | true;\n    external?: string[] | true;\n    /**\n     * Define the target for the ssr build. The browser field in package.json\n     * is ignored for node but used if webworker is the target\n     * @default 'node'\n     */\n    target?: SSRTarget;\n    /**\n     * Control over which dependencies are optimized during SSR and esbuild options\n     * During build:\n     *   no external CJS dependencies are optimized by default\n     * During dev:\n     *   explicit no external CJS dependencies are optimized by default\n     * @experimental\n     */\n    optimizeDeps?: SsrDepOptimizationOptions;\n    resolve?: {\n        /**\n         * Conditions that are used in the plugin pipeline. The default value is the root config's `resolve.conditions`.\n         *\n         * Use this to override the default ssr conditions for the ssr build.\n         *\n         * @default rootConfig.resolve.conditions\n         */\n        conditions?: string[];\n        /**\n         * Conditions that are used during ssr import (including `ssrLoadModule`) of externalized dependencies.\n         *\n         * @default []\n         */\n        externalConditions?: string[];\n    };\n}\ninterface ResolvedSSROptions extends SSROptions {\n    target: SSRTarget;\n    optimizeDeps: SsrDepOptimizationOptions;\n}\n\ninterface FsUtils {\n    existsSync: (path: string) => boolean;\n    isDirectory: (path: string) => boolean;\n    tryResolveRealFile: (path: string, preserveSymlinks?: boolean) => string | undefined;\n    tryResolveRealFileWithExtensions: (path: string, extensions: string[], preserveSymlinks?: boolean) => string | undefined;\n    tryResolveRealFileOrType: (path: string, preserveSymlinks?: boolean) => {\n        path?: string;\n        type: 'directory' | 'file';\n    } | undefined;\n    initWatcher?: (watcher: FSWatcher) => void;\n}\n\ninterface ResolveOptions {\n    /**\n     * @default ['browser', 'module', 'jsnext:main', 'jsnext']\n     */\n    mainFields?: string[];\n    conditions?: string[];\n    /**\n     * @default ['.mjs', '.js', '.mts', '.ts', '.jsx', '.tsx', '.json']\n     */\n    extensions?: string[];\n    dedupe?: string[];\n    /**\n     * @default false\n     */\n    preserveSymlinks?: boolean;\n}\ninterface InternalResolveOptions extends Required<ResolveOptions> {\n    root: string;\n    isBuild: boolean;\n    isProduction: boolean;\n    ssrConfig?: SSROptions;\n    packageCache?: PackageCache;\n    fsUtils?: FsUtils;\n    /**\n     * src code mode also attempts the following:\n     * - resolving /xxx as URLs\n     * - resolving bare imports from optimized deps\n     */\n    asSrc?: boolean;\n    tryIndex?: boolean;\n    tryPrefix?: string;\n    preferRelative?: boolean;\n    isRequire?: boolean;\n    isFromTsImporter?: boolean;\n    tryEsmOnly?: boolean;\n    scan?: boolean;\n    ssrOptimizeCheck?: boolean;\n    getDepsOptimizer?: (ssr: boolean) => DepsOptimizer | undefined;\n    shouldExternalize?: (id: string, importer?: string) => boolean | undefined;\n}\n\n// This file is autogenerated by build-prefixes.js. DO NOT EDIT!\n\ninterface Targets {\n  android?: number,\n  chrome?: number,\n  edge?: number,\n  firefox?: number,\n  ie?: number,\n  ios_saf?: number,\n  opera?: number,\n  safari?: number,\n  samsung?: number\n}\n\ninterface Drafts {\n  /** Whether to enable @custom-media rules. */\n  customMedia?: boolean\n}\n\ninterface NonStandard {\n  /** Whether to enable the non-standard >>> and /deep/ selector combinators used by Angular and Vue. */\n  deepSelectorCombinator?: boolean\n}\n\ninterface PseudoClasses {\n  hover?: string,\n  active?: string,\n  focus?: string,\n  focusVisible?: string,\n  focusWithin?: string\n}\n\ninterface CSSModulesConfig {\n  /** The pattern to use when renaming class names and other identifiers. Default is `[hash]_[local]`. */\n  pattern?: string,\n  /** Whether to rename dashed identifiers, e.g. custom properties. */\n  dashedIdents?: boolean\n}\n\n/**\n * Options are spread, so you can also use options that are not typed here like\n * visitor (not exposed because it would impact too much the bundle size)\n */\ntype LightningCSSOptions = {\n  targets?: Targets\n  include?: number\n  exclude?: number\n  drafts?: Drafts\n  nonStandard?: NonStandard\n  pseudoClasses?: PseudoClasses\n  unusedSymbols?: string[]\n  cssModules?: CSSModulesConfig\n  errorRecovery?: boolean\n}\n\ninterface CSSOptions {\n    /**\n     * Using lightningcss is an experimental option to handle CSS modules,\n     * assets and imports via Lightning CSS. It requires to install it as a\n     * peer dependency. This is incompatible with the use of preprocessors.\n     *\n     * @default 'postcss'\n     * @experimental\n     */\n    transformer?: 'postcss' | 'lightningcss';\n    /**\n     * https://github.com/css-modules/postcss-modules\n     */\n    modules?: CSSModulesOptions | false;\n    /**\n     * Options for preprocessors.\n     *\n     * In addition to options specific to each processors, Vite supports `additionalData` option.\n     * The `additionalData` option can be used to inject extra code for each style content.\n     */\n    preprocessorOptions?: Record<string, any>;\n    /**\n     * If this option is set, preprocessors will run in workers when possible.\n     * `true` means the number of CPUs minus 1.\n     *\n     * @default 0\n     * @experimental\n     */\n    preprocessorMaxWorkers?: number | true;\n    postcss?: string | (PostCSS.ProcessOptions & {\n        plugins?: PostCSS.AcceptedPlugin[];\n    });\n    /**\n     * Enables css sourcemaps during dev\n     * @default false\n     * @experimental\n     */\n    devSourcemap?: boolean;\n    /**\n     * @experimental\n     */\n    lightningcss?: LightningCSSOptions;\n}\ninterface CSSModulesOptions {\n    getJSON?: (cssFileName: string, json: Record<string, string>, outputFileName: string) => void;\n    scopeBehaviour?: 'global' | 'local';\n    globalModulePaths?: RegExp[];\n    exportGlobals?: boolean;\n    generateScopedName?: string | ((name: string, filename: string, css: string) => string);\n    hashPrefix?: string;\n    /**\n     * default: undefined\n     */\n    localsConvention?: 'camelCase' | 'camelCaseOnly' | 'dashes' | 'dashesOnly' | ((originalClassName: string, generatedClassName: string, inputFile: string) => string);\n}\ntype ResolvedCSSOptions = Omit<CSSOptions, 'lightningcss'> & {\n    lightningcss?: LightningCSSOptions & {\n        targets: LightningCSSOptions['targets'];\n    };\n};\ninterface PreprocessCSSResult {\n    code: string;\n    map?: SourceMapInput;\n    modules?: Record<string, string>;\n    deps?: Set<string>;\n}\n/**\n * @experimental\n */\ndeclare function preprocessCSS(code: string, filename: string, config: ResolvedConfig): Promise<PreprocessCSSResult>;\ndeclare function formatPostcssSourceMap(rawMap: ExistingRawSourceMap, file: string): Promise<ExistingRawSourceMap>;\n\ninterface HtmlTagDescriptor {\n    tag: string;\n    attrs?: Record<string, string | boolean | undefined>;\n    children?: string | HtmlTagDescriptor[];\n    /**\n     * default: 'head-prepend'\n     */\n    injectTo?: 'head' | 'body' | 'head-prepend' | 'body-prepend';\n}\ntype IndexHtmlTransformResult = string | HtmlTagDescriptor[] | {\n    html: string;\n    tags: HtmlTagDescriptor[];\n};\ninterface IndexHtmlTransformContext {\n    /**\n     * public path when served\n     */\n    path: string;\n    /**\n     * filename on disk\n     */\n    filename: string;\n    server?: ViteDevServer;\n    bundle?: OutputBundle;\n    chunk?: OutputChunk;\n    originalUrl?: string;\n}\ntype IndexHtmlTransformHook = (this: void, html: string, ctx: IndexHtmlTransformContext) => IndexHtmlTransformResult | void | Promise<IndexHtmlTransformResult | void>;\ntype IndexHtmlTransform = IndexHtmlTransformHook | {\n    order?: 'pre' | 'post' | null;\n    /**\n     * @deprecated renamed to `order`\n     */\n    enforce?: 'pre' | 'post';\n    /**\n     * @deprecated renamed to `handler`\n     */\n    transform: IndexHtmlTransformHook;\n} | {\n    order?: 'pre' | 'post' | null;\n    /**\n     * @deprecated renamed to `order`\n     */\n    enforce?: 'pre' | 'post';\n    handler: IndexHtmlTransformHook;\n};\n\n/**\n * Vite plugins extends the Rollup plugin interface with a few extra\n * vite-specific options. A valid vite plugin is also a valid Rollup plugin.\n * On the contrary, a Rollup plugin may or may NOT be a valid vite universal\n * plugin, since some Rollup features do not make sense in an unbundled\n * dev server context. That said, as long as a rollup plugin doesn't have strong\n * coupling between its bundle phase and output phase hooks then it should\n * just work (that means, most of them).\n *\n * By default, the plugins are run during both serve and build. When a plugin\n * is applied during serve, it will only run **non output plugin hooks** (see\n * rollup type definition of {@link rollup#PluginHooks}). You can think of the\n * dev server as only running `const bundle = rollup.rollup()` but never calling\n * `bundle.generate()`.\n *\n * A plugin that expects to have different behavior depending on serve/build can\n * export a factory function that receives the command being run via options.\n *\n * If a plugin should be applied only for server or build, a function format\n * config file can be used to conditional determine the plugins to use.\n */\ninterface Plugin<A = any> extends rollup.Plugin<A> {\n    /**\n     * Enforce plugin invocation tier similar to webpack loaders. Hooks ordering\n     * is still subject to the `order` property in the hook object.\n     *\n     * Plugin invocation order:\n     * - alias resolution\n     * - `enforce: 'pre'` plugins\n     * - vite core plugins\n     * - normal plugins\n     * - vite build plugins\n     * - `enforce: 'post'` plugins\n     * - vite build post plugins\n     */\n    enforce?: 'pre' | 'post';\n    /**\n     * Apply the plugin only for serve or build, or on certain conditions.\n     */\n    apply?: 'serve' | 'build' | ((this: void, config: UserConfig, env: ConfigEnv) => boolean);\n    /**\n     * Modify vite config before it's resolved. The hook can either mutate the\n     * passed-in config directly, or return a partial config object that will be\n     * deeply merged into existing config.\n     *\n     * Note: User plugins are resolved before running this hook so injecting other\n     * plugins inside  the `config` hook will have no effect.\n     */\n    config?: ObjectHook<(this: void, config: UserConfig, env: ConfigEnv) => Omit<UserConfig, 'plugins'> | null | void | Promise<Omit<UserConfig, 'plugins'> | null | void>>;\n    /**\n     * Use this hook to read and store the final resolved vite config.\n     */\n    configResolved?: ObjectHook<(this: void, config: ResolvedConfig) => void | Promise<void>>;\n    /**\n     * Configure the vite server. The hook receives the {@link ViteDevServer}\n     * instance. This can also be used to store a reference to the server\n     * for use in other hooks.\n     *\n     * The hooks will be called before internal middlewares are applied. A hook\n     * can return a post hook that will be called after internal middlewares\n     * are applied. Hook can be async functions and will be called in series.\n     */\n    configureServer?: ObjectHook<ServerHook>;\n    /**\n     * Configure the preview server. The hook receives the {@link PreviewServer}\n     * instance. This can also be used to store a reference to the server\n     * for use in other hooks.\n     *\n     * The hooks are called before other middlewares are applied. A hook can\n     * return a post hook that will be called after other middlewares are\n     * applied. Hooks can be async functions and will be called in series.\n     */\n    configurePreviewServer?: ObjectHook<PreviewServerHook>;\n    /**\n     * Transform index.html.\n     * The hook receives the following arguments:\n     *\n     * - html: string\n     * - ctx?: vite.ServerContext (only present during serve)\n     * - bundle?: rollup.OutputBundle (only present during build)\n     *\n     * It can either return a transformed string, or a list of html tag\n     * descriptors that will be injected into the `<head>` or `<body>`.\n     *\n     * By default the transform is applied **after** vite's internal html\n     * transform. If you need to apply the transform before vite, use an object:\n     * `{ order: 'pre', handler: hook }`\n     */\n    transformIndexHtml?: IndexHtmlTransform;\n    /**\n     * Perform custom handling of HMR updates.\n     * The handler receives a context containing changed filename, timestamp, a\n     * list of modules affected by the file change, and the dev server instance.\n     *\n     * - The hook can return a filtered list of modules to narrow down the update.\n     *   e.g. for a Vue SFC, we can narrow down the part to update by comparing\n     *   the descriptors.\n     *\n     * - The hook can also return an empty array and then perform custom updates\n     *   by sending a custom hmr payload via server.ws.send().\n     *\n     * - If the hook doesn't return a value, the hmr update will be performed as\n     *   normal.\n     */\n    handleHotUpdate?: ObjectHook<(this: void, ctx: HmrContext) => Array<ModuleNode> | void | Promise<Array<ModuleNode> | void>>;\n    /**\n     * extend hooks with ssr flag\n     */\n    resolveId?: ObjectHook<(this: PluginContext, source: string, importer: string | undefined, options: {\n        attributes: Record<string, string>;\n        custom?: CustomPluginOptions;\n        ssr?: boolean;\n        isEntry: boolean;\n    }) => Promise<ResolveIdResult> | ResolveIdResult>;\n    load?: ObjectHook<(this: PluginContext, id: string, options?: {\n        ssr?: boolean;\n    }) => Promise<LoadResult> | LoadResult>;\n    transform?: ObjectHook<(this: TransformPluginContext, code: string, id: string, options?: {\n        ssr?: boolean;\n    }) => Promise<rollup.TransformResult> | rollup.TransformResult>;\n}\ntype HookHandler<T> = T extends ObjectHook<infer H> ? H : T;\ntype PluginWithRequiredHook<K extends keyof Plugin> = Plugin & {\n    [P in K]: NonNullable<Plugin[P]>;\n};\n\ninterface JsonOptions {\n    /**\n     * Generate a named export for every property of the JSON object\n     * @default true\n     */\n    namedExports?: boolean;\n    /**\n     * Generate performant output as JSON.parse(\"stringified\").\n     * Enabling this will disable namedExports.\n     * @default false\n     */\n    stringify?: boolean;\n}\n\ninterface ConfigEnv {\n    /**\n     * 'serve': during dev (`vite` command)\n     * 'build': when building for production (`vite build` command)\n     */\n    command: 'build' | 'serve';\n    mode: string;\n    isSsrBuild?: boolean;\n    isPreview?: boolean;\n}\n/**\n * spa: include SPA fallback middleware and configure sirv with `single: true` in preview\n *\n * mpa: only include non-SPA HTML middlewares\n *\n * custom: don't include HTML middlewares\n */\ntype AppType = 'spa' | 'mpa' | 'custom';\ntype UserConfigFnObject = (env: ConfigEnv) => UserConfig;\ntype UserConfigFnPromise = (env: ConfigEnv) => Promise<UserConfig>;\ntype UserConfigFn = (env: ConfigEnv) => UserConfig | Promise<UserConfig>;\ntype UserConfigExport = UserConfig | Promise<UserConfig> | UserConfigFnObject | UserConfigFnPromise | UserConfigFn;\n/**\n * Type helper to make it easier to use vite.config.ts\n * accepts a direct {@link UserConfig} object, or a function that returns it.\n * The function receives a {@link ConfigEnv} object.\n */\ndeclare function defineConfig(config: UserConfig): UserConfig;\ndeclare function defineConfig(config: Promise<UserConfig>): Promise<UserConfig>;\ndeclare function defineConfig(config: UserConfigFnObject): UserConfigFnObject;\ndeclare function defineConfig(config: UserConfigExport): UserConfigExport;\ntype PluginOption = Plugin | false | null | undefined | PluginOption[] | Promise<Plugin | false | null | undefined | PluginOption[]>;\ninterface UserConfig {\n    /**\n     * Project root directory. Can be an absolute path, or a path relative from\n     * the location of the config file itself.\n     * @default process.cwd()\n     */\n    root?: string;\n    /**\n     * Base public path when served in development or production.\n     * @default '/'\n     */\n    base?: string;\n    /**\n     * Directory to serve as plain static assets. Files in this directory are\n     * served and copied to build dist dir as-is without transform. The value\n     * can be either an absolute file system path or a path relative to project root.\n     *\n     * Set to `false` or an empty string to disable copied static assets to build dist dir.\n     * @default 'public'\n     */\n    publicDir?: string | false;\n    /**\n     * Directory to save cache files. Files in this directory are pre-bundled\n     * deps or some other cache files that generated by vite, which can improve\n     * the performance. You can use `--force` flag or manually delete the directory\n     * to regenerate the cache files. The value can be either an absolute file\n     * system path or a path relative to project root.\n     * Default to `.vite` when no `package.json` is detected.\n     * @default 'node_modules/.vite'\n     */\n    cacheDir?: string;\n    /**\n     * Explicitly set a mode to run in. This will override the default mode for\n     * each command, and can be overridden by the command line --mode option.\n     */\n    mode?: string;\n    /**\n     * Define global variable replacements.\n     * Entries will be defined on `window` during dev and replaced during build.\n     */\n    define?: Record<string, any>;\n    /**\n     * Array of vite plugins to use.\n     */\n    plugins?: PluginOption[];\n    /**\n     * Configure resolver\n     */\n    resolve?: ResolveOptions & {\n        alias?: AliasOptions;\n    };\n    /**\n     * HTML related options\n     */\n    html?: HTMLOptions;\n    /**\n     * CSS related options (preprocessors and CSS modules)\n     */\n    css?: CSSOptions;\n    /**\n     * JSON loading options\n     */\n    json?: JsonOptions;\n    /**\n     * Transform options to pass to esbuild.\n     * Or set to `false` to disable esbuild.\n     */\n    esbuild?: ESBuildOptions | false;\n    /**\n     * Specify additional picomatch patterns to be treated as static assets.\n     */\n    assetsInclude?: string | RegExp | (string | RegExp)[];\n    /**\n     * Server specific options, e.g. host, port, https...\n     */\n    server?: ServerOptions;\n    /**\n     * Build specific options\n     */\n    build?: BuildOptions;\n    /**\n     * Preview specific options, e.g. host, port, https...\n     */\n    preview?: PreviewOptions;\n    /**\n     * Dep optimization options\n     */\n    optimizeDeps?: DepOptimizationOptions;\n    /**\n     * SSR specific options\n     */\n    ssr?: SSROptions;\n    /**\n     * Experimental features\n     *\n     * Features under this field could change in the future and might NOT follow semver.\n     * Please be careful and always pin Vite's version when using them.\n     * @experimental\n     */\n    experimental?: ExperimentalOptions;\n    /**\n     * Legacy options\n     *\n     * Features under this field only follow semver for patches, they could be removed in a\n     * future minor version. Please always pin Vite's version to a minor when using them.\n     */\n    legacy?: LegacyOptions;\n    /**\n     * Log level.\n     * @default 'info'\n     */\n    logLevel?: LogLevel;\n    /**\n     * Custom logger.\n     */\n    customLogger?: Logger;\n    /**\n     * @default true\n     */\n    clearScreen?: boolean;\n    /**\n     * Environment files directory. Can be an absolute path, or a path relative from\n     * root.\n     * @default root\n     */\n    envDir?: string;\n    /**\n     * Env variables starts with `envPrefix` will be exposed to your client source code via import.meta.env.\n     * @default 'VITE_'\n     */\n    envPrefix?: string | string[];\n    /**\n     * Worker bundle options\n     */\n    worker?: {\n        /**\n         * Output format for worker bundle\n         * @default 'iife'\n         */\n        format?: 'es' | 'iife';\n        /**\n         * Vite plugins that apply to worker bundle. The plugins returned by this function\n         * should be new instances every time it is called, because they are used for each\n         * rollup worker bundling process.\n         */\n        plugins?: () => PluginOption[];\n        /**\n         * Rollup options to build worker bundle\n         */\n        rollupOptions?: Omit<RollupOptions, 'plugins' | 'input' | 'onwarn' | 'preserveEntrySignatures'>;\n    };\n    /**\n     * Whether your application is a Single Page Application (SPA),\n     * a Multi-Page Application (MPA), or Custom Application (SSR\n     * and frameworks with custom HTML handling)\n     * @default 'spa'\n     */\n    appType?: AppType;\n}\ninterface HTMLOptions {\n    /**\n     * A nonce value placeholder that will be used when generating script/style tags.\n     *\n     * Make sure that this placeholder will be replaced with a unique value for each request by the server.\n     */\n    cspNonce?: string;\n}\ninterface ExperimentalOptions {\n    /**\n     * Append fake `&lang.(ext)` when queries are specified, to preserve the file extension for following plugins to process.\n     *\n     * @experimental\n     * @default false\n     */\n    importGlobRestoreExtension?: boolean;\n    /**\n     * Allow finegrain control over assets and public files paths\n     *\n     * @experimental\n     */\n    renderBuiltUrl?: RenderBuiltAssetUrl;\n    /**\n     * Enables support of HMR partial accept via `import.meta.hot.acceptExports`.\n     *\n     * @experimental\n     * @default false\n     */\n    hmrPartialAccept?: boolean;\n    /**\n     * Skips SSR transform to make it easier to use Vite with Node ESM loaders.\n     * @warning Enabling this will break normal operation of Vite's SSR in development mode.\n     *\n     * @experimental\n     * @default false\n     */\n    skipSsrTransform?: boolean;\n}\ninterface LegacyOptions {\n    /**\n     * In Vite 4, SSR-externalized modules (modules not bundled and loaded by Node.js at runtime)\n     * are implicitly proxied in dev to automatically handle `default` and `__esModule` access.\n     * However, this does not correctly reflect how it works in the Node.js runtime, causing\n     * inconsistencies between dev and prod.\n     *\n     * In Vite 5, the proxy is removed so dev and prod are consistent, but if you still require\n     * the old behaviour, you can enable this option. If so, please leave your feedback at\n     * https://github.com/vitejs/vite/discussions/14697.\n     */\n    proxySsrExternalModules?: boolean;\n}\ninterface ResolvedWorkerOptions {\n    format: 'es' | 'iife';\n    plugins: (bundleChain: string[]) => Promise<Plugin[]>;\n    rollupOptions: RollupOptions;\n}\ninterface InlineConfig extends UserConfig {\n    configFile?: string | false;\n    envFile?: false;\n}\ntype ResolvedConfig = Readonly<Omit<UserConfig, 'plugins' | 'css' | 'assetsInclude' | 'optimizeDeps' | 'worker' | 'build'> & {\n    configFile: string | undefined;\n    configFileDependencies: string[];\n    inlineConfig: InlineConfig;\n    root: string;\n    base: string;\n    publicDir: string;\n    cacheDir: string;\n    command: 'build' | 'serve';\n    mode: string;\n    isWorker: boolean;\n    isProduction: boolean;\n    envDir: string;\n    env: Record<string, any>;\n    resolve: Required<ResolveOptions> & {\n        alias: Alias[];\n    };\n    plugins: readonly Plugin[];\n    css: ResolvedCSSOptions;\n    esbuild: ESBuildOptions | false;\n    server: ResolvedServerOptions;\n    build: ResolvedBuildOptions;\n    preview: ResolvedPreviewOptions;\n    ssr: ResolvedSSROptions;\n    assetsInclude: (file: string) => boolean;\n    logger: Logger;\n    createResolver: (options?: Partial<InternalResolveOptions>) => ResolveFn;\n    optimizeDeps: DepOptimizationOptions;\n    worker: ResolvedWorkerOptions;\n    appType: AppType;\n    experimental: ExperimentalOptions;\n} & PluginHookUtils>;\ninterface PluginHookUtils {\n    getSortedPlugins: <K extends keyof Plugin>(hookName: K) => PluginWithRequiredHook<K>[];\n    getSortedPluginHooks: <K extends keyof Plugin>(hookName: K) => NonNullable<HookHandler<Plugin[K]>>[];\n}\ntype ResolveFn = (id: string, importer?: string, aliasOnly?: boolean, ssr?: boolean) => Promise<string | undefined>;\ndeclare function resolveConfig(inlineConfig: InlineConfig, command: 'build' | 'serve', defaultMode?: string, defaultNodeEnv?: string, isPreview?: boolean): Promise<ResolvedConfig>;\ndeclare function sortUserPlugins(plugins: (Plugin | Plugin[])[] | undefined): [Plugin[], Plugin[], Plugin[]];\ndeclare function loadConfigFromFile(configEnv: ConfigEnv, configFile?: string, configRoot?: string, logLevel?: LogLevel, customLogger?: Logger): Promise<{\n    path: string;\n    config: UserConfig;\n    dependencies: string[];\n} | null>;\n\ndeclare function buildErrorMessage(err: RollupError, args?: string[], includeStack?: boolean): string;\n\ninterface FetchModuleOptions {\n    inlineSourceMap?: boolean;\n    processSourceMap?<T extends NonNullable<TransformResult['map']>>(map: T): T;\n}\n/**\n * Fetch module information for Vite runtime.\n * @experimental\n */\ndeclare function fetchModule(server: ViteDevServer, url: string, importer?: string, options?: FetchModuleOptions): Promise<FetchResult>;\n\ndeclare const VERSION: string;\n\ndeclare const isCSSRequest: (request: string) => boolean;\n/**\n * @deprecated use build.rollupOptions.output.manualChunks or framework specific configuration\n */\ndeclare class SplitVendorChunkCache {\n    cache: Map<string, boolean>;\n    constructor();\n    reset(): void;\n}\n/**\n * @deprecated use build.rollupOptions.output.manualChunks or framework specific configuration\n */\ndeclare function splitVendorChunk(options?: {\n    cache?: SplitVendorChunkCache;\n}): GetManualChunk;\n/**\n * @deprecated use build.rollupOptions.output.manualChunks or framework specific configuration\n */\ndeclare function splitVendorChunkPlugin(): Plugin;\n\n/**\n * Inlined to keep `@rollup/pluginutils` in devDependencies\n */\ntype FilterPattern = ReadonlyArray<string | RegExp> | string | RegExp | null;\ndeclare const createFilter: (include?: FilterPattern, exclude?: FilterPattern, options?: {\n    resolve?: string | false | null;\n}) => (id: string | unknown) => boolean;\ndeclare const rollupVersion: string;\ndeclare function normalizePath(id: string): string;\ndeclare function mergeConfig<D extends Record<string, any>, O extends Record<string, any>>(defaults: D extends Function ? never : D, overrides: O extends Function ? never : O, isRoot?: boolean): Record<string, any>;\ndeclare function mergeAlias(a?: AliasOptions, b?: AliasOptions): AliasOptions | undefined;\n\ninterface SendOptions {\n    etag?: string;\n    cacheControl?: string;\n    headers?: OutgoingHttpHeaders;\n    map?: SourceMap | {\n        mappings: '';\n    } | null;\n}\ndeclare function send(req: IncomingMessage, res: ServerResponse, content: string | Buffer, type: string, options: SendOptions): void;\n\n/**\n * Search up for the nearest workspace root\n */\ndeclare function searchForWorkspaceRoot(current: string, root?: string): string;\n\n/**\n * Check if the url is allowed to be served, via the `server.fs` config.\n */\ndeclare function isFileServingAllowed(url: string, server: ViteDevServer): boolean;\n\ndeclare function loadEnv(mode: string, envDir: string, prefixes?: string | string[]): Record<string, string>;\ndeclare function resolveEnvPrefix({ envPrefix, }: UserConfig): string[];\n\ntype Manifest = Record<string, ManifestChunk>;\ninterface ManifestChunk {\n    src?: string;\n    file: string;\n    css?: string[];\n    assets?: string[];\n    isEntry?: boolean;\n    name?: string;\n    isDynamicEntry?: boolean;\n    imports?: string[];\n    dynamicImports?: string[];\n}\n\n/**\n * @experimental\n */\ninterface MainThreadRuntimeOptions extends Omit<ViteRuntimeOptions, 'root' | 'fetchModule' | 'hmr'> {\n    /**\n     * Disable HMR or configure HMR logger.\n     */\n    hmr?: false | {\n        logger?: false | HMRLogger;\n    };\n    /**\n     * Provide a custom module runner. This controls how the code is executed.\n     */\n    runner?: ViteModuleRunner;\n}\n/**\n * Create an instance of the Vite SSR runtime that support HMR.\n * @experimental\n */\ndeclare function createViteRuntime(server: ViteDevServer, options?: MainThreadRuntimeOptions): Promise<ViteRuntime>;\n\n/**\n * The connector class to establish HMR communication between the server and the Vite runtime.\n * @experimental\n */\ndeclare class ServerHMRConnector implements HMRRuntimeConnection {\n    private handlers;\n    private hmrChannel;\n    private hmrClient;\n    private connected;\n    constructor(server: ViteDevServer);\n    isReady(): boolean;\n    send(message: string): void;\n    onUpdate(handler: (payload: HMRPayload) => void): void;\n}\n\nexport { type Alias, type AliasOptions, type AnymatchFn, type AnymatchPattern, type AppType, type AwaitWriteFinishOptions, type BindCLIShortcutsOptions, type BuildOptions, type CLIShortcut, type CSSModulesOptions, type CSSOptions, type CommonServerOptions, type ConfigEnv, Connect, type CorsOptions, type CorsOrigin, type DepOptimizationConfig, type DepOptimizationMetadata, type DepOptimizationOptions, type ESBuildOptions, type ESBuildTransformResult, type ExperimentalOptions, type ExportsData, FSWatcher, type FetchModuleOptions, type FileSystemServeOptions, type FilterPattern, type HMRBroadcaster, type HMRBroadcasterClient, type HMRChannel, type HTMLOptions, type HmrContext, type HmrOptions, type HookHandler, type HtmlTagDescriptor, HttpProxy, type HttpServer, type IndexHtmlTransform, type IndexHtmlTransformContext, type IndexHtmlTransformHook, type IndexHtmlTransformResult, type InlineConfig, type InternalResolveOptions, type JsonOptions, type LegacyOptions, type LibraryFormats, type LibraryOptions, type LightningCSSOptions, type LogErrorOptions, type LogLevel, type LogOptions, type LogType, type Logger, type LoggerOptions, type MainThreadRuntimeOptions, type Manifest, type ManifestChunk, type MapToFunction, type AnymatchMatcher as Matcher, ModuleGraph, ModuleNode, type ModulePreloadOptions, type OptimizedDepInfo, type Plugin, PluginContainer, type PluginHookUtils, type PluginOption, type PreprocessCSSResult, type PreviewOptions, type PreviewServer, type PreviewServerHook, type ProxyOptions, type RenderBuiltAssetUrl, type ResolveFn, type ResolveModulePreloadDependenciesFn, type ResolveOptions, type ResolvedBuildOptions, type ResolvedCSSOptions, type ResolvedConfig, type ResolvedModulePreloadOptions, type ResolvedPreviewOptions, type ResolvedSSROptions, type ResolvedServerOptions, type ResolvedServerUrls, type ResolvedUrl, type ResolvedWorkerOptions, type ResolverFunction, type ResolverObject, type RollupCommonJSOptions, type RollupDynamicImportVarsOptions, type SSROptions, type SSRTarget, type SendOptions, type ServerHMRChannel, ServerHMRConnector, type ServerHook, type ServerOptions, SplitVendorChunkCache, type SsrDepOptimizationOptions, Terser, type TerserOptions, type TransformOptions, type TransformResult, type UserConfig, type UserConfigExport, type UserConfigFn, type UserConfigFnObject, type UserConfigFnPromise, type ViteDevServer, type WatchOptions, WebSocket, WebSocketAlias, type WebSocketClient, type WebSocketCustomListener, WebSocketServer, build, buildErrorMessage, createFilter, createLogger, createServer, createViteRuntime, defineConfig, fetchModule, formatPostcssSourceMap, isCSSRequest, isFileServingAllowed, loadConfigFromFile, loadEnv, mergeAlias, mergeConfig, normalizePath, optimizeDeps, preprocessCSS, preview, resolveConfig, resolveEnvPrefix, rollupVersion, searchForWorkspaceRoot, send, sortUserPlugins, splitVendorChunk, splitVendorChunkPlugin, transformWithEsbuild, VERSION as version };\n"
        }
    ]
}
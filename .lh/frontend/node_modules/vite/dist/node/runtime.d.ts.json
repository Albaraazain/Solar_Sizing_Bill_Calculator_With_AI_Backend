{
    "sourceFile": "frontend/node_modules/vite/dist/node/runtime.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1733415129519,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1733415129519,
            "name": "Commit-0",
            "content": "import { V as ViteRuntimeOptions, b as ViteModuleRunner, M as ModuleCacheMap, c as HMRClient, R as ResolvedResult, d as ViteRuntimeModuleContext } from './types.d-aGj9QkWt.js';\nexport { a as FetchFunction, F as FetchResult, e as HMRConnection, H as HMRLogger, g as HMRRuntimeConnection, f as ModuleCache, S as SSRImportMetadata, h as ViteRuntimeImportMeta, s as ssrDynamicImportKey, i as ssrExportAllKey, j as ssrImportKey, k as ssrImportMetaKey, l as ssrModuleExportsKey } from './types.d-aGj9QkWt.js';\nimport 'vite/types/hot.js';\nimport 'vite/types/hmrPayload.js';\nimport 'vite/types/customEvent.js';\n\ninterface ViteRuntimeDebugger {\n    (formatter: unknown, ...args: unknown[]): void;\n}\ndeclare class ViteRuntime {\n    options: ViteRuntimeOptions;\n    runner: ViteModuleRunner;\n    private debug?;\n    /**\n     * Holds the cache of modules\n     * Keys of the map are ids\n     */\n    moduleCache: ModuleCacheMap;\n    hmrClient?: HMRClient;\n    entrypoints: Set<string>;\n    private idToUrlMap;\n    private fileToIdMap;\n    private envProxy;\n    private _destroyed;\n    private _resetSourceMapSupport?;\n    constructor(options: ViteRuntimeOptions, runner: ViteModuleRunner, debug?: ViteRuntimeDebugger | undefined);\n    /**\n     * URL to execute. Accepts file path, server path or id relative to the root.\n     */\n    executeUrl<T = any>(url: string): Promise<T>;\n    /**\n     * Entrypoint URL to execute. Accepts file path, server path or id relative to the root.\n     * In the case of a full reload triggered by HMR, this is the module that will be reloaded.\n     * If this method is called multiple times, all entrypoints will be reloaded one at a time.\n     */\n    executeEntrypoint<T = any>(url: string): Promise<T>;\n    /**\n     * Clear all caches including HMR listeners.\n     */\n    clearCache(): void;\n    /**\n     * Clears all caches, removes all HMR listeners, and resets source map support.\n     * This method doesn't stop the HMR connection.\n     */\n    destroy(): Promise<void>;\n    /**\n     * Returns `true` if the runtime has been destroyed by calling `destroy()` method.\n     */\n    isDestroyed(): boolean;\n    private invalidateFiles;\n    private normalizeEntryUrl;\n    private processImport;\n    private cachedRequest;\n    private cachedModule;\n    protected directRequest(id: string, fetchResult: ResolvedResult, _callstack: string[]): Promise<any>;\n}\n\ndeclare class ESModulesRunner implements ViteModuleRunner {\n    runViteModule(context: ViteRuntimeModuleContext, code: string): Promise<any>;\n    runExternalModule(filepath: string): Promise<any>;\n}\n\nexport { ESModulesRunner, ModuleCacheMap, ResolvedResult, ViteModuleRunner, ViteRuntime, ViteRuntimeModuleContext, ViteRuntimeOptions };\n"
        }
    ]
}